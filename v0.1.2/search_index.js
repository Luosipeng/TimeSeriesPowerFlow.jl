var documenterSearchIndex = {"docs":
[{"location":"modules/utils/#Utils-Module","page":"Utils","title":"Utils Module","text":"","category":"section"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"This module provides utility functions for power system analysis, including data conversion, network topology analysis, and various helper functions for working with power system models.","category":"page"},{"location":"modules/utils/#Data-Conversion-Functions","page":"Utils","title":"Data Conversion Functions","text":"","category":"section"},{"location":"modules/utils/#External-to-Internal-Indexing","page":"Utils","title":"External to Internal Indexing","text":"","category":"section"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"ext2int(bus::Matrix{Float64}, gen::Matrix{Float64}, branch::Matrix{Float64})","category":"page"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"Converts external bus numbers to consecutive internal bus numbers.","category":"page"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"Arguments:\nbus: Bus data matrix\ngen: Generator data matrix\nbranch: Branch data matrix\nReturns: Converted matrices and mapping between external and internal indices","category":"page"},{"location":"modules/utils/#Internal-to-External-Indexing","page":"Utils","title":"Internal to External Indexing","text":"","category":"section"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"int2ext(i2e::Vector{Int}, bus::Matrix{Float64}, gen::Matrix{Float64}, branch::Matrix{Float64})","category":"page"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"Converts internal consecutive bus numbers back to original external bus numbers.","category":"page"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"Arguments:\ni2e: Mapping from internal to external bus numbers\nbus: Bus data matrix with internal indexing\ngen: Generator data matrix with internal indexing\nbranch: Branch data matrix with internal indexing\nReturns: Matrices with external indexing restored","category":"page"},{"location":"modules/utils/#Network-Topology-Analysis","page":"Utils","title":"Network Topology Analysis","text":"","category":"section"},{"location":"modules/utils/#Island-Detection","page":"Utils","title":"Island Detection","text":"","category":"section"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"find_islands(jpc::JPC)","category":"page"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"Identifies electrically isolated islands in an AC power system.","category":"page"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"Arguments:\njpc: Power system case data structure\nReturns:\nislands: List of islands, each containing connected bus indices\nisolated_buses: List of isolated buses","category":"page"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"extract_islands(jpc::JPC)","category":"page"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"Extracts electrically isolated islands from a power system case.","category":"page"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"Arguments:\njpc: Power system case data structure\nReturns:\nVector{JPC}: List of JPC objects, each representing a separate island","category":"page"},{"location":"modules/utils/#Node-Mapping","page":"Utils","title":"Node Mapping","text":"","category":"section"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"create_node_mapping(case::JuliaPowerCase)","category":"page"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"Creates numbering mapping for nodes and detects duplicate nodes.","category":"page"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"Arguments:\ncase: JuliaPowerCase object\nReturns: A dictionary mapping node names to IDs","category":"page"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"resolve_node_mapping(node_id, node_merge_map)","category":"page"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"Resolves the final mapping of a node by traversing through a node merge map.","category":"page"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"Arguments:\nnode_id: The initial node ID to resolve\nnode_merge_map: A dictionary mapping source nodes to destination nodes\nReturns: The final resolved node ID after following all mappings","category":"page"},{"location":"modules/utils/#Virtual-Node-Handling","page":"Utils","title":"Virtual Node Handling","text":"","category":"section"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"merge_virtual_nodes(case::JuliaPowerCase)","category":"page"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"Merges virtual nodes in a power system case and updates all connected elements.","category":"page"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"Arguments:\ncase: JuliaPowerCase object\nReturns: Updated case with virtual nodes merged","category":"page"},{"location":"modules/utils/#Data-Extraction","page":"Utils","title":"Data Extraction","text":"","category":"section"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"extract_data(sheet_name::String, xf)","category":"page"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"Extracts data from an Excel worksheet into a matrix.","category":"page"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"Arguments:\nsheet_name: Name of the worksheet\nxf: Excel file object\nReturns: Matrix containing the extracted data","category":"page"},{"location":"modules/utils/#Data-Format-Conversion","page":"Utils","title":"Data Format Conversion","text":"","category":"section"},{"location":"modules/utils/#MATLAB-to-Julia-Conversion","page":"Utils","title":"MATLAB to Julia Conversion","text":"","category":"section"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"parse_matlab_case_file(filepath)","category":"page"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"Parses a MATPOWER case file in MATLAB format and converts it to Julia data structures.","category":"page"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"Arguments:\nfilepath: Path to the MATLAB case file\nReturns: Parsed power system data in Julia format","category":"page"},{"location":"modules/utils/#JuliaPowerCase-to-JPC-Conversion","page":"Utils","title":"JuliaPowerCase to JPC Conversion","text":"","category":"section"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"JuliaPowerCase2Jpc(case::JuliaPowerCase)","category":"page"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"Converts a JuliaPowerCase object to a JPC (Julia Power Case) object.","category":"page"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"Arguments:\ncase: JuliaPowerCase object\nReturns: JPC object","category":"page"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"JuliaPowerCase2Jpc_3ph(case::JuliaPowerCase)","category":"page"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"Converts a JuliaPowerCase object to a three-phase JPC_3ph object.","category":"page"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"Arguments:\ncase: JuliaPowerCase object\nReturns:\njpc_3ph: The converted three-phase power system model\nAdditional parameters for three-phase analysis","category":"page"},{"location":"modules/utils/#ETAP-Data-Import","page":"Utils","title":"ETAP Data Import","text":"","category":"section"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"load_julia_power_data(file_path::String)","category":"page"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"Loads power system data from an Excel file and converts it to a JuliaPowerCase structure.","category":"page"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"Arguments:\nfile_path: Path to the Excel file\nReturns: JuliaPowerCase structure containing all power system components","category":"page"},{"location":"modules/utils/#Indexing-Constants","page":"Utils","title":"Indexing Constants","text":"","category":"section"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"The idx.jl file provides constants for indexing into power system data matrices:","category":"page"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"function idx_bus()\n    # define bus types\n    PQ      = 1;\n    PV      = 2;\n    REF     = 3;\n    NONE    = 4;\n    \n    # define the indices\n    BUS_I       = 1;    # bus number (1 to 29997)\n    BUS_TYPE    = 2;    # bus type (1-PQ, 2-PV, 3-ref, 4-isolated)\n    PD          = 3;    # Pd, real power demand (MW)\n    QD          = 4;    # Qd, reactive power demand (MVAr)\n    GS          = 5;    # Gs, shunt conductance (MW at V = 1.0 p.u.)\n    BS          = 6;    # Bs, shunt susceptance (MVAr at V = 1.0 p.u.)\n    BUS_AREA    = 7;    # area number, 1-100\n    VM          = 8;    # Vm, voltage magnitude (p.u.)\n    VA          = 9;    # Va, voltage angle (degrees)\n    BASE_KV     = 10;   # baseKV, base voltage (kV)\n    ZONE        = 11;   # zone, loss zone (1-999)\n    VMAX        = 12;   # maxVm, maximum voltage magnitude (p.u.)\n    VMIN        = 13;   # minVm, minimum voltage magnitude (p.u.)\n    \n    return PQ, PV, REF, NONE, BUS_I, BUS_TYPE, PD, QD, GS, BS, BUS_AREA, VM, VA, BASE_KV, ZONE, VMAX, VMIN\nend","category":"page"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"Similar indexing functions are provided for generators, branches, and other power system components.","category":"page"},{"location":"modules/utils/#Types","page":"Utils","title":"Types","text":"","category":"section"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"The Types.jl file defines data structures for power system analysis, including:","category":"page"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"mutable struct MicrogridPlanningProblem\n    # Constants\n    bigM::Float64\n    \n    # Planning parameters\n    nPV::Int\n    nBESS::Int\n    DeltaPV::Float64\n    DeltaBESS::Float64\n    \n    # Technical parameters\n    soc0::Float64\n    soc_max::Float64\n    soc_min::Float64\n    eta_ug::Float64\n    eff_ch::Float64\n    eff_dc::Float64\n    \n    # Economic parameters\n    pv_unit_cost::Float64\n    ess_unit_cost_e::Float64\n    ess_unit_cost_p::Float64\n    ug_unit_cost::Float64\n    carbon_permit_price::Float64\n    carbon_emission_coeff::Float64\n    npv::Float64\n\n    # Reliability parameters\n    ug_prob::Float64\n    mg_prob::Float64\n    power_requirements::Float64\n    energy_requirements::Float64\n    pv_power_factor::Float64\n    pv_energy_factor::Float64\n    \n    # Carbon emission limit\n    carbon_limit::Float64\n    # Uncertainty parameters\n    ns::Int\n    ws::Vector{Float64}\n    T::Int\n    ppv_un::Int\n    pl::Int\n    fl::Int\n    ug_status::Int\n    ele_price::Int\n    carbon_price::Int\n    carbon_emission_ug::Int\n    nu::Int\n    NU::Int\n    \n    # Indices\n    IPV::Int\n    IESS::Int\n    IPESS::Int\n    PUG::Int\n    CARBON_PERMIT::Int\n    CARBON::Int\n    NX::Int\n    \n    # First stage constraints\n    lx::Vector{Float64}\n    ux::Vector{Float64}\n    vtypex::Vector{Char}\n    Aeq::SparseMatrixCSC{Float64, Int}\n    beq::Vector{Float64}\n    A::SparseMatrixCSC{Float64, Int}\n    b::Vector{Float64}\n    \n    # Objective function\n    c::Vector{Float64}\n\n    # Second stage indices\n    pug::Int\n    pug_sold::Int\n    ppv::Int\n    pess_ch::Int\n    pess_dc::Int\n    eess::Int\n    iess_ch::Int\n    iess_dc::Int\n    wpv::Int\n    wpess_dc::Int\n    wpess_ch::Int\n    plc::Int\n    pf::Int\n    ny::Int\n    NY::Int\nend","category":"page"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"mutable struct JuliaPowerCase\n    version::String\n    baseMVA::Float32\n    basef::Float32\n    \n    # AC Network Components\n    busesAC::Vector{Bus}                # Matches busAC in JPC\n    branchesAC::Vector{Line}            # Matches branchAC in JPC\n    loadsAC::Vector{Load}               # Matches loadAC in JPC\n    loadsAC_flex::Vector{FlexLoad}      # Matches loadAC_flex in JPC\n    loadsAC_asymm::Vector{AsymmetricLoad}  # Matches loadAC_asymm in JPC\n    # branches3ph::Vector{ThreePhaseBranch}  # Matches branch3ph in JPC\n    gensAC::Vector{Generator}            # Matches genAC in JPC\n    \n    # DC Network Components\n    busesDC::Vector{BusDC}              # Matches busDC in JPC\n    branchesDC::Vector{LineDC}          # Matches branchDC in JPC\n    loadsDC::Vector{LoadDC}          # Matches loadDC in JPC\n    \n    # Distributed Energy Resources\n    sgensAC::Vector{StaticGenerator}     # Matches sgenAC in JPC\n    storages::Vector{Storage}            # Matches storage in JPC\n    storageetap::Vector{Storageetap}      # Matches storageetap in JPC\n    sgensDC::Vector{StaticGeneratorDC}   # Matches sgenDC in JPC\n    pvarray::Vector{PVArray}          # Matches pv_array in JPC\n    ACPVSystems::Vector{ACPVSystem}  # Matches AC PV systems in JPC\n    \n    # Special Components\n    converters::Vector{Converter}        # Matches converter in JPC\n    ext_grids::Vector{ExternalGrid}      # Matches ext_grid in JPC\n    hvcbs::Vector{HighVoltageCircuitBreaker}  # Matches hvcb in JPC\n    microgrids::Vector{Microgrid}        # Matches microgrid in JPC\n    \n    # Original components without direct JPC equivalents (preserved)\n    transformers_2w::Vector{Transformer2W}\n    transformers_3w::Vector{Transformer3W}\n    transformers_2w_etap::Vector{Transformer2Wetap}\n    charging_stations::Vector{ChargingStation}\n    chargers::Vector{Charger}\n    ev_aggregators::Vector{EVAggregator}\n    virtual_power_plants::Vector{VirtualPowerPlant}\n    carbon_time_series::Vector{CarbonTimeSeries}\n    equipment_carbon::Vector{EquipmentCarbon}\n    \n    # Lookup dictionaries\n    bus_name_to_id::Dict{String, Int}\n    busdc_name_to_id::Dict{String, Int}\n    zone_to_id::Dict{String, Int}\n    area_to_id::Dict{String, Int}\nend","category":"page"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"mutable struct JPC\n    version::String\n    baseMVA::Float64\n    success::Bool\n    iterationsAC::Int\n    iterationsDC::Int\n    \n    # AC Network Components\n    busAC::Array{Float64,2}         # Bus data \n    genAC::Array{Float64,2}         # Generator data \n    branchAC::Array{Float64,2}      # Branch data\n    loadAC::Array{Float64,2}        # Load data\n    loadAC_flex::Array{Float64,2}   # Flexible load data \n    loadAC_asymm::Array{Float64,2}  # Asymmetric load data\n    branch3ph::Array{Float64,2}     # Three-phase branch data\n    \n    # DC Network Components\n    busDC::Array{Float64,2}         # DC bus data \n    branchDC::Array{Float64,2}      # DC branch data \n    genDC::Array{Float64,2}         # DC generator data \n    loadDC::Array{Float64,2}        # DC load data\n    \n    # Distributed Energy Resources\n    sgenAC::Array{Float64,2}        # Solar/PV generation data \n    storageetap::Array{Float64,2}  # Energy storage system data\n    storage::Array{Float64,2}       # Energy storage system data \n    sgenDC::Array{Float64,2}        # DC-connected PV data \n    pv::Array{Float64,2}          # PV array data \n    pv_acsystem::Array{Float64,2}  # AC PV systems data \n    \n    # Special Components\n    converter::Array{Float64,2}     # AC/DC converter data \n    ext_grid::Array{Float64,2}      # External grid data \n    hvcb::Array{Float64,2}          # High voltage circuit breaker data \n    microgrid::Array{Float64,2}     # Microgrid data \nend","category":"page"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"mutable struct JPC_3ph\n    version::String\n    baseMVA::Float32\n    basef::Float32\n    mode::String\n    success::Bool  # Flag indicating if three-phase power flow converged\n    iterations::Int  # Number of iterations for three-phase power flow\n    \n    # AC Network Components - Matrix representations of JuliaPowerCase components\n    busAC_0::Array{Float64,2}  # Phase A bus data\n    busAC_1::Array{Float64,2}  # Phase B bus data\n    busAC_2::Array{Float64,2}  # Phase C bus data\n\n    branchAC_0::Array{Float64,2}  # Phase A branch data\n    branchAC_1::Array{Float64,2}  # Phase B branch data\n    branchAC_2::Array{Float64,2}  # Phase C branch data\n\n    loadAC_0::Array{Float64,2}  # Phase A load data\n    loadAC_1::Array{Float64,2}  # Phase B load data\n    loadAC_2::Array{Float64,2}  # Phase C load data\n\n    genAC_0::Array{Float64,2}  # Phase A generator data\n    genAC_1::Array{Float64,2}  # Phase B generator data\n    genAC_2::Array{Float64,2}  # Phase C generator data\n\n    storageAC::Array{Float64,2}  # Storage data\n    \n    # DC Network Components\n    busDC::Array{Float64,2}  # DC bus data\n    branchDC::Array{Float64,2}  # DC branch data\n    loadDC::Array{Float64,2}  # DC load data\n    genDC::Array{Float64,2}  # DC generator data\n    storageDC::Array{Float64,2}  # DC storage data\n    \n    # Special Components\n    ext_grid::Array{Float64,2}  # External grid data\n    switche::Array{Float64,2}  # Switch data\n\n    # Three-phase power flow results\n    res_bus_3ph::Array{Float64,2}  # Bus results from three-phase power flow\n    res_loadsAC_3ph::Array{Float64,2}  # Load results from three-phase power flow\n    res_ext_grid_3ph::Array{Float64,2}  # External grid results from three-phase power flow\n    \n    # Lookup dictionaries\n    bus_name_to_id::Dict{String, Int}\n    zone_to_id::Dict{String, Int}\n    area_to_id::Dict{String, Int}\nend","category":"page"},{"location":"modules/utils/","page":"Utils","title":"Utils","text":"This structure contains all parameters and variables for microgrid planning optimization.","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/#How-to-Cite-HyDistFlow.jl","page":"References","title":"How to Cite HyDistFlow.jl","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"If you use HyDistFlow.jl in your research, please use the following citation format:","category":"page"},{"location":"references/","page":"References","title":"References","text":"@software{HyDistFlow2025,\n  author = {Sipeng Luo,Tianyang Zhao,Zhaohong Bie},\n  title = {HyDistFlow.jl: a Julia package for time series power flow analysis},\n  year = {2025},\n  url = {https://github.com/Luosipeng/HyDistFlow.jl}\n}","category":"page"},{"location":"references/#Referenced-Code-and-Inspirations","page":"References","title":"Referenced Code and Inspirations","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"HyDistFlow.jl was developed with inspiration from and reference to the following open source projects:","category":"page"},{"location":"references/#MATPOWER","page":"References","title":"MATPOWER","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"An open-source MATLAB package for power system simulation and optimization.","category":"page"},{"location":"references/","page":"References","title":"References","text":"@article{zimmerman2011matpower,\n  title = {MATPOWER: Steady-State Operations, Planning and Analysis Tools for Power Systems Research and Education},\n  author = {Zimmerman, Ray D and Murillo-S{\\'a}nchez, Carlos E and Thomas, Robert J},\n  journal = {IEEE Transactions on Power Systems},\n  volume = {26},\n  number = {1},\n  pages = {12--19},\n  year = {2011},\n  doi = {10.1109/TPWRS.2010.2051168}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"@software{zimmerman2024matpower,\n  author = {Zimmerman, Ray D and Murillo-S{\\'a}nchez, Carlos E},\n  title = {MATPOWER},\n  version = {8.0},\n  year = {2024},\n  url = {https://matpower.org},\n  doi = {10.5281/zenodo.11212330}\n}","category":"page"},{"location":"references/#PandaPower","page":"References","title":"PandaPower","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"An easy to use open source tool for power system modeling, analysis and optimization with a high degree of automation.","category":"page"},{"location":"references/","page":"References","title":"References","text":"@ARTICLE{pandapower.2018,\n    author={L. Thurner and A. Scheidler and F. Sch{\\\"a}fer and J. Menke and J. Dollichon and F. Meier and S. Meinecke and M. Braun},\n    journal={IEEE Transactions on Power Systems},\n    title={pandapower — An Open-Source Python Tool for Convenient Modeling, Analysis, and Optimization of Electric Power Systems},\n    year={2018},\n    month={Nov},\n    volume={33},\n    number={6},\n    pages={6510-6521},\n    doi={10.1109/TPWRS.2018.2829021},\n    ISSN={0885-8950}}","category":"page"},{"location":"references/#External-Packages","page":"References","title":"External Packages","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"HyDistFlow.jl relies on several external packages. We acknowledge and thank the contributors of these packages:","category":"page"},{"location":"references/#AMD.jl","page":"References","title":"AMD.jl","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"A Julia interface to the AMD library of Amestoy, Davis and Duff.","category":"page"},{"location":"references/","page":"References","title":"References","text":"@software{montoison2020amd,\n  author = {Montoison, Alexis and Orban, Dominique and Siqueira, Abel S. and contributors},\n  title = {AMD.jl: A Julia interface to the AMD library of Amestoy, Davis and Duff},\n  year = {2020},\n  month = {5},\n  day = {3},\n  url = {https://github.com/JuliaSmoothOptimizers/AMD.jl},\n  doi = {10.5281/zenodo.3381898},\n  version = {0.4.0}\n}","category":"page"},{"location":"references/#DataFrames.jl","page":"References","title":"DataFrames.jl","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Tools for working with tabular data in Julia.","category":"page"},{"location":"references/","page":"References","title":"References","text":"@article{JSSv107i04,\n title={DataFrames.jl: Flexible and Fast Tabular Data in Julia},\n volume={107},\n url={https://www.jstatsoft.org/index.php/jss/article/view/v107i04},\n doi={10.18637/jss.v107.i04},\n abstract={DataFrames.jl is a package written for and in the Julia language offering flexible and efficient handling of tabular data sets in memory. Thanks to Julia’s unique strengths, it provides an appealing set of features: Rich support for standard data processing tasks and excellent flexibility and efficiency for more advanced and non-standard operations. We present the fundamental design of the package and how it compares with implementations of data frames in other languages, its main features, performance, and possible extensions. We conclude with a practical illustration of typical data processing operations.},\n number={4},\n journal={Journal of Statistical Software},\n author={Bouchet-Valat, Milan and Kamiński, Bogumił},\n year={2023},\n pages={1--32}\n}","category":"page"},{"location":"references/#Plots.jl","page":"References","title":"Plots.jl","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"A powerful visualization interface and toolkit in Julia.","category":"page"},{"location":"references/","page":"References","title":"References","text":"@article{PlotsJL,\n  doi = {https://doi.org/10.5334/jors.431},\n  url = {https://openresearchsoftware.metajnl.com/articles/10.5334/jors.431/},\n  author = {Christ, Simon and Schwabeneder, Daniel and Rackauckas, Christopher and Borregaard, Michael Krabbe and Breloff, Thomas},\n  keywords = {Graphics (cs.GR), FOS: Computer and information sciences, FOS: Computer and information sciences, I.3.3},\n  title = {Plots.jl -- a user extendable plotting API for the julia programming language},\n  publisher = {Journal of Open Research Software},\n  year = {2023},\n  copyright = {Creative Commons Attribution 4.0 International}\n}","category":"page"},{"location":"references/#JuMP.jl","page":"References","title":"JuMP.jl","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"A Powerful optimization interface and toolkit in Julia","category":"page"},{"location":"references/","page":"References","title":"References","text":"@article{Lubin2023,\n    author = {Miles Lubin and Oscar Dowson and Joaquim {Dias Garcia} and Joey Huchette and Beno{\\^i}t Legat and Juan Pablo Vielma},\n    title = {{JuMP} 1.0: {R}ecent improvements to a modeling language for mathematical optimization},\n    journal = {Mathematical Programming Computation},\n    year = {2023},\n    doi = {10.1007/s12532-023-00239-3}\n}","category":"page"},{"location":"references/#Graphs.jl","page":"References","title":"Graphs.jl","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"A powerful graph analysis tool in Julia","category":"page"},{"location":"references/","page":"References","title":"References","text":"@misc{Graphs2021,\n  author       = {Fairbanks, James and Besan{\\c{c}}on, Mathieu and Simon, Sch{\\\"o}lly and Hoffiman, J{\\'u}lio and Eubank, Nick and Karpinski, Stefan},\n  title        = {JuliaGraphs/Graphs.jl: an optimized graphs package for the Julia programming language},\n  year         = 2021,\n  url = {https://github.com/JuliaGraphs/Graphs.jl/}\n}","category":"page"},{"location":"references/#LinearOperator","page":"References","title":"LinearOperator","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"A Julia Linear Operator Package","category":"page"},{"location":"references/","page":"References","title":"References","text":"@software{leconte2023linearoperators,\n  title = {LinearOperators.jl: Linear Operators for Julia},\n  author = {Leconte, Geoffroy and Orban, Dominique and Soares Siqueira, Abel and contributors},\n  year = {2023},\n  month = {12},\n  day = {11},\n  version = {2.6.0},\n  doi = {10.5281/zenodo.2559295},\n  url = {https://github.com/JuliaSmoothOptimizers/LinearOperators.jl},\n  keywords = {Linear Algebra, Julia, Matrix Factorization},\n  license = {MPL-2.0}\n}","category":"page"},{"location":"references/#Krylov","page":"References","title":"Krylov","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"A Julia basket of hand-picked Krylov methods","category":"page"},{"location":"references/","page":"References","title":"References","text":"@article{montoison2023krylov,\n  title = {Krylov.jl: A Julia basket of hand-picked {Krylov} methods},\n  author = {Montoison, Alexis and Orban, Dominique},\n  journal = {Journal of Open Source Software},\n  volume = {8},\n  number = {89},\n  pages = {5187},\n  year = {2023},\n  month = {9},\n  day = {26},\n  publisher = {Open Journals},\n  doi = {10.21105/joss.05187},\n  url = {https://joss.theoj.org/papers/10.21105/joss.05187},\n  issn = {2475-9066}\n}","category":"page"},{"location":"references/#KrylovKit","page":"References","title":"KrylovKit","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"A Julia package collecting a number of Krylov-based algorithms for linear problems, singular value and eigenvalue problems and the application of functions of linear maps or operators to vectors.","category":"page"},{"location":"references/","page":"References","title":"References","text":"@software{haegeman2024krylovkit,\n  author = {Haegeman, Jutho},\n  title = {KrylovKit},\n  version = {0.7.0},\n  year = {2024},\n  month = {3},\n  day = {14},\n  doi = {10.5281/zenodo.10622234},\n  url = {https://github.com/Jutho/KrylovKit.jl}\n}","category":"page"},{"location":"references/#Acknowledgments","page":"References","title":"Acknowledgments","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"We would like to thank all the contributors to the Julia ecosystem whose work has made this package possible. Special thanks to the developers of the packages listed above for their valuable tools that form the foundation of HyDistFlow.jl.","category":"page"},{"location":"modules/componentmodel/#ComponentModel-Module","page":"ComponentModel","title":"ComponentModel Module","text":"","category":"section"},{"location":"modules/componentmodel/","page":"ComponentModel","title":"ComponentModel","text":"The ComponentModel module provides a comprehensive framework for modeling and simulating power systems, including AC, DC, and hybrid AC/DC components, as well as carbon emission models. This document outlines the key components and their usage within the module.","category":"page"},{"location":"modules/componentmodel/#AC-Power-System-Components","page":"ComponentModel","title":"AC Power System Components","text":"","category":"section"},{"location":"modules/componentmodel/","page":"ComponentModel","title":"ComponentModel","text":"AC components serve as the fundamental building blocks for constructing power system models, including buses, lines, transformers, generators, and loads.","category":"page"},{"location":"modules/componentmodel/#Bus-Components","page":"ComponentModel","title":"Bus Components","text":"","category":"section"},{"location":"modules/componentmodel/","page":"ComponentModel","title":"ComponentModel","text":"Buses are nodes in power systems that connect various devices such as generators, loads, lines, and transformers.","category":"page"},{"location":"modules/componentmodel/","page":"ComponentModel","title":"ComponentModel","text":"# Create a new bus\nbus1 = Bus(\n    index = 1,\n    name = \"Bus 1\",\n    vn_kv = 110.0,  # Nominal voltage (kV)\n    type = \"b\",     # Slack bus\n    zone = 1,\n    v_pu = 1.0,     # Initial voltage (per unit)\n    theta_degree = 0.0  # Initial angle (degrees)\n)","category":"page"},{"location":"modules/componentmodel/#Line-Components","page":"ComponentModel","title":"Line Components","text":"","category":"section"},{"location":"modules/componentmodel/","page":"ComponentModel","title":"ComponentModel","text":"Line components model AC transmission and distribution lines through impedance parameters.","category":"page"},{"location":"modules/componentmodel/","page":"ComponentModel","title":"ComponentModel","text":"# Create a new line\nline1 = Line(\n    index = 1,\n    name = \"Line 1-2\",\n    from_bus = 1,\n    to_bus = 2,\n    length_km = 10.0,\n    r_ohm_per_km = 0.1,  # Resistance per km (Ω/km)\n    x_ohm_per_km = 0.3,  # Reactance per km (Ω/km)\n    c_nf_per_km = 10.0,  # Capacitance per km (nF/km)\n    max_i_ka = 0.5,      # Maximum current capacity (kA)\n    df = 1.0,            # Derating factor\n    parallel = 1         # Number of parallel lines\n)","category":"page"},{"location":"modules/componentmodel/#Transformer-Components","page":"ComponentModel","title":"Transformer Components","text":"","category":"section"},{"location":"modules/componentmodel/","page":"ComponentModel","title":"ComponentModel","text":"Transformer components model voltage conversion devices connecting buses at different voltage levels.","category":"page"},{"location":"modules/componentmodel/","page":"ComponentModel","title":"ComponentModel","text":"# Create a two-winding transformer\ntransformer = Transformer2W(\n    index = 1,\n    name = \"T1\",\n    std_type = \"160 MVA 110/20 kV\",\n    hv_bus = 1,       # High voltage bus\n    lv_bus = 2,       # Low voltage bus\n    sn_mva = 160.0,   # Rated power (MVA)\n    vn_hv_kv = 110.0, # HV rated voltage (kV)\n    vn_lv_kv = 20.0,  # LV rated voltage (kV)\n    vk_percent = 10.0,# Short-circuit impedance (%)\n    vkr_percent = 0.3,# Short-circuit losses (%)\n    pfe_kw = 60.0,    # Iron losses (kW)\n    i0_percent = 0.1, # No-load current (%)\n    shift_degree = 0.0,# Phase shift angle (degrees)\n    tap_side = \"hv\",  # Tap side (high voltage)\n    tap_pos = 0,      # Tap position\n    tap_neutral = 0,  # Neutral tap position\n    tap_min = -10,    # Minimum tap position\n    tap_max = 10      # Maximum tap position\n)","category":"page"},{"location":"modules/componentmodel/#Generator-Components","page":"ComponentModel","title":"Generator Components","text":"","category":"section"},{"location":"modules/componentmodel/","page":"ComponentModel","title":"ComponentModel","text":"Static generator components provide simplified modeling of generating units.","category":"page"},{"location":"modules/componentmodel/","page":"ComponentModel","title":"ComponentModel","text":"# Create a static generator\ngen = StaticGenerator(\n    index = 1,\n    name = \"Generator 1\",\n    bus = 1,           # Connected bus number\n    p_mw = 100.0,      # Active power output (MW)\n    q_mvar = 20.0,     # Reactive power output (MVar)\n    scaling = 1.0,     # Power scaling factor\n    max_p_mw = 150.0,  # Maximum active power limit (MW)\n    min_p_mw = 50.0,   # Minimum active power limit (MW)\n    max_q_mvar = 50.0, # Maximum reactive power limit (MVar)\n    min_q_mvar = -50.0 # Minimum reactive power limit (MVar)\n)","category":"page"},{"location":"modules/componentmodel/#Load-Components","page":"ComponentModel","title":"Load Components","text":"","category":"section"},{"location":"modules/componentmodel/","page":"ComponentModel","title":"ComponentModel","text":"Load components model power consumption in electrical systems.","category":"page"},{"location":"modules/componentmodel/","page":"ComponentModel","title":"ComponentModel","text":"# Create a load\nload = Load(\n    index = 1,\n    name = \"Load 1\",\n    bus = 2,          # Connected bus number\n    p_mw = 50.0,      # Active power demand (MW)\n    q_mvar = 10.0,    # Reactive power demand (MVar)\n    scaling = 1.0,    # Power scaling factor\n    type = \"wye\"      # Load type (Y-connected)\n)","category":"page"},{"location":"modules/componentmodel/#Network-Construction-Example","page":"ComponentModel","title":"Network Construction Example","text":"","category":"section"},{"location":"modules/componentmodel/","page":"ComponentModel","title":"ComponentModel","text":"using ComponentModel\nusing Utils\n\n# Create power system model\ncase = JuliaPowerCase()\n\n# Add buses\nbus1 = Bus(1, \"Bus 1\", 110.0, \"b\", 1, 1.0, 0.0)\nbus2 = Bus(2, \"Bus 2\", 110.0, \"pq\", 1, 1.0, 0.0)\nbus3 = Bus(3, \"Bus 3\", 20.0, \"pq\", 1, 1.0, 0.0)\npush!(case.busesAC, bus1)\npush!(case.busesAC, bus2)\npush!(case.busesAC, bus3)\n\n# Add generator\ngen = StaticGenerator(1, \"Gen 1\", 1, 100.0, 20.0, 1.0, 150.0, 50.0, 50.0, -50.0)\npush!(case.gensAC, gen)\n\n# Add line\nline = Line(1, \"Line 1-2\", 1, 2, 10.0, 0.1, 0.3, 10.0, 0.5, 1.0, 1)\npush!(case.branchesAC, line)\n\n# Add transformer\ntransformer = Transformer2W(1, \"T1\", \"160 MVA 110/20 kV\", 2, 3, 160.0, 110.0, 20.0, 10.0, 0.3, 60.0, 0.1, 0.0, \"hv\", 0, 0, -10, 10)\npush!(case.transformers_2w, transformer)\n\n# Add load\nload = Load(1, \"Load 1\", 3, 50.0, 10.0, 1.0, \"wye\")\npush!(case.loadsAC, load)\n","category":"page"},{"location":"modules/componentmodel/#Converters","page":"ComponentModel","title":"Converters","text":"","category":"section"},{"location":"modules/componentmodel/","page":"ComponentModel","title":"ComponentModel","text":"Converters model power electronic interfaces between AC and DC systems in power networks.","category":"page"},{"location":"modules/componentmodel/#Converter-Structure","page":"ComponentModel","title":"Converter Structure","text":"","category":"section"},{"location":"modules/componentmodel/","page":"ComponentModel","title":"ComponentModel","text":"# Create a new converter\nconverter = Converter(\n    index = 1,\n    name = \"VSC1\",\n    bus_ac = 5,         # Connected AC bus number\n    bus_dc = 101,       # Connected DC bus number\n    p_mw = 100.0,       # Active power transfer (MW)\n    q_mvar = 25.0,      # Reactive power at AC side (MVar)\n    vm_ac_pu = 1.0,     # AC voltage magnitude (per unit)\n    vm_dc_pu = 1.05,    # DC voltage magnitude (per unit)\n    loss_percent = 1.5, # Losses as percentage of active power\n    loss_mw = 1.5,      # Losses (MW)\n    max_p_mw = 200.0,   # Maximum active power limit (MW)\n    min_p_mw = -200.0,  # Minimum active power limit (MW)\n    max_q_mvar = 100.0, # Maximum reactive power limit (MVar)\n    min_q_mvar = -100.0,# Minimum reactive power limit (MVar)\n    control_mode = \"P-Q\", # Control mode\n    droop_kv = 0.0,     # DC voltage droop parameter\n    in_service = true,  # Operational status\n    controllable = true # Controllability status\n)","category":"page"},{"location":"modules/componentmodel/#Control-Modes","page":"ComponentModel","title":"Control Modes","text":"","category":"section"},{"location":"modules/componentmodel/","page":"ComponentModel","title":"ComponentModel","text":"Converters can operate in different control modes:","category":"page"},{"location":"modules/componentmodel/","page":"ComponentModel","title":"ComponentModel","text":"P-Q Mode: The converter controls active and reactive power\nVdc-Q Mode: The converter controls DC voltage and reactive power\nP-Vac Mode: The converter controls active power and AC voltage\nVdc-Vac Mode: The converter controls DC voltage and AC voltage","category":"page"},{"location":"modules/componentmodel/#Integration-Example","page":"ComponentModel","title":"Integration Example","text":"","category":"section"},{"location":"modules/componentmodel/","page":"ComponentModel","title":"ComponentModel","text":"using ComponentModel\nusing Utils\n\n# Create power system model\ncase = JuliaPowerCase()\n\n# Add AC and DC buses\nac_bus = Bus(1, \"AC Bus\", 400.0, \"pq\", 1, 1.0, 0.0)\ndc_bus = DCBus(101, \"DC Bus\", 500.0, 1.0)\npush!(case.busesAC, ac_bus)\npush!(case.busesDC, dc_bus)\n\n# Add converter\nconverter = Converter(\n    1, \"VSC1\", 1, 101, 100.0, 25.0, 1.0, 1.05, \n    1.5, 1.5, 200.0, -200.0, 100.0, -100.0, \n    \"P-Q\", 0.0, true, true\n)\npush!(case.converters, converter)\n","category":"page"},{"location":"modules/componentmodel/#DC-Components","page":"ComponentModel","title":"DC Components","text":"","category":"section"},{"location":"modules/componentmodel/","page":"ComponentModel","title":"ComponentModel","text":"DC components serve as building blocks for constructing DC power system models.","category":"page"},{"location":"modules/componentmodel/#DC-Bus-Components","page":"ComponentModel","title":"DC Bus Components","text":"","category":"section"},{"location":"modules/componentmodel/","page":"ComponentModel","title":"ComponentModel","text":"# Create a new DC bus\ndc_bus = BusDC(\n    index = 101,\n    name = \"DC Bus 1\",\n    vn_kv = 500.0,  # Nominal voltage (kV)\n    type = \"b\",     # Slack bus\n    zone = 1,\n    v_pu = 1.0,     # Initial voltage (per unit)\n    in_service = true\n)","category":"page"},{"location":"modules/componentmodel/#DC-Line-Components","page":"ComponentModel","title":"DC Line Components","text":"","category":"section"},{"location":"modules/componentmodel/","page":"ComponentModel","title":"ComponentModel","text":"# Create a new DC line\ndc_line = LineDC(\n    index = 1,\n    name = \"DC Line 1-2\",\n    from_bus = 101,\n    to_bus = 102,\n    length_km = 100.0,\n    r_ohm_per_km = 0.01,  # Resistance per km (Ω/km)\n    max_i_ka = 2.0,       # Maximum current capacity (kA)\n    in_service = true\n)","category":"page"},{"location":"modules/componentmodel/#DC-Generator-Components","page":"ComponentModel","title":"DC Generator Components","text":"","category":"section"},{"location":"modules/componentmodel/","page":"ComponentModel","title":"ComponentModel","text":"# Create a DC static generator\ndc_gen = StaticGeneratorDC(\n    index = 1,\n    name = \"DC Generator 1\",\n    bus = 101,         # Connected DC bus number\n    p_mw = 200.0,      # Active power output (MW)\n    scaling = 1.0,     # Power scaling factor\n    max_p_mw = 300.0,  # Maximum active power limit (MW)\n    min_p_mw = 0.0,    # Minimum active power limit (MW)\n    in_service = true\n)","category":"page"},{"location":"modules/componentmodel/#DC-Load-Components","page":"ComponentModel","title":"DC Load Components","text":"","category":"section"},{"location":"modules/componentmodel/","page":"ComponentModel","title":"ComponentModel","text":"# Create a DC load\ndc_load = LoadDC(\n    index = 1,\n    name = \"DC Load 1\",\n    bus = 102,          # Connected DC bus number\n    p_mw = 150.0,       # Active power demand (MW)\n    const_z_percent = 0.0,  # Percentage of constant impedance load\n    const_i_percent = 0.0,  # Percentage of constant current load\n    const_p_percent = 100.0, # Percentage of constant power load\n    scaling = 1.0,      # Power scaling factor\n    in_service = true\n)","category":"page"},{"location":"modules/componentmodel/#DC-Storage-Components","page":"ComponentModel","title":"DC Storage Components","text":"","category":"section"},{"location":"modules/componentmodel/","page":"ComponentModel","title":"ComponentModel","text":"# Create a DC storage system\ndc_storage = Storage(\n    index = 1,\n    name = \"Battery Storage 1\",\n    bus = 101,                # Connected DC bus number\n    power_capacity_mw = 50.0, # Maximum power capacity (MW)\n    energy_capacity_mwh = 200.0, # Energy storage capacity (MWh)\n    soc_init = 0.5,           # Initial state of charge (50%)\n    min_soc = 0.1,            # Minimum allowed state of charge (10%)\n    max_soc = 0.9,            # Maximum allowed state of charge (90%)\n    efficiency = 0.95,        # Round-trip efficiency\n    self_discharge = 0.001,   # Self-discharge rate per hour\n    p_mw = 0.0,               # Initial active power (MW, positive for charging)\n    in_service = true\n)","category":"page"},{"location":"modules/componentmodel/#DC-Network-Construction-Example","page":"ComponentModel","title":"DC Network Construction Example","text":"","category":"section"},{"location":"modules/componentmodel/","page":"ComponentModel","title":"ComponentModel","text":"using ComponentModel\nusing Utils\n\n# Create DC power system model\ncase = JuliaPowerCase()\n\n# Add DC buses\nbus1 = BusDC(101, \"DC Bus 1\", 500.0, \"b\", 1, 1.0, true)\nbus2 = BusDC(102, \"DC Bus 2\", 500.0, \"pq\", 1, 1.0, true)\npush!(case.busesDC, bus1)\npush!(case.busesDC, bus2)\n\n# Add DC generator\ngen = StaticGeneratorDC(1, \"DC Gen 1\", 101, 200.0, 1.0, 300.0, 0.0, true)\npush!(case.sgensDC, gen)\n\n# Add DC line\nline = LineDC(1, \"DC Line 1-2\", 101, 102, 100.0, 0.01, 2.0, true)\npush!(case.branchesDC, line)\n\n# Add DC load\nload = LoadDC(1, \"DC Load 1\", 102, 150.0, 0.0, 0.0, 100.0, 1.0, true)\npush!(case.loadsDC, load)\n\n# Add DC storage\nstorage = Storage(1, \"Battery 1\", 101, 50.0, 200.0, 0.5, 0.1, 0.9, 0.95, 0.001, 0.0, true)\npush!(case.storages, storage)\n","category":"page"},{"location":"modules/componentmodel/#Hybrid-AC/DC-Systems","page":"ComponentModel","title":"Hybrid AC/DC Systems","text":"","category":"section"},{"location":"modules/componentmodel/","page":"ComponentModel","title":"ComponentModel","text":"DC components can be integrated with AC components to form hybrid AC/DC power systems through converter components.","category":"page"},{"location":"modules/componentmodel/","page":"ComponentModel","title":"ComponentModel","text":"using ComponentModel\nusing Utils\n\n# Create hybrid power system model\ncase = JuliaPowerCase()\n\n# Add AC buses\nac_bus1 = Bus(1, \"AC Bus 1\", 400.0, \"b\", 1, 1.0, 0.0)\nac_bus2 = Bus(2, \"AC Bus 2\", 400.0, \"pq\", 1, 1.0, 0.0)\npush!(case.busesAC, ac_bus1)\npush!(case.busesAC, ac_bus2)\n\n# Add DC buses\ndc_bus1 = BusDC(101, \"DC Bus 1\", 500.0, \"b\", 1, 1.0, true)\ndc_bus2 = BusDC(102, \"DC Bus 2\", 500.0, \"pq\", 1, 1.0, true)\npush!(case.busesDC, dc_bus1)\npush!(case.busesDC, dc_bus2)\n\n# Add AC generator\nac_gen = StaticGenerator(1, \"AC Gen\", 1, 300.0, 100.0, 1.0, 500.0, 0.0, 200.0, -200.0)\npush!(case.sgensAC, ac_gen)\n\n# Add DC generator\ndc_gen = StaticGeneratorDC(1, \"DC Gen\", 102, 100.0, 1.0, 200.0, 0.0, true)\npush!(case.sgensDC, dc_gen)\n\n# Add converter between AC and DC\nconverter = Converter(1, \"VSC\", 2, 101, 150.0, 50.0, 1.0, 1.0, 1.0, 1.5, 200.0, -200.0, 100.0, -100.0, \"P-Q\", 0.0, true, true)\npush!(case.converters, converter)\n\n","category":"page"},{"location":"modules/componentmodel/#Carbon-Emission-Models","page":"ComponentModel","title":"Carbon Emission Models","text":"","category":"section"},{"location":"modules/componentmodel/","page":"ComponentModel","title":"ComponentModel","text":"Carbon emission modeling components enable users to incorporate carbon emissions data into power system analyses.","category":"page"},{"location":"modules/componentmodel/#Carbon-Time-Series","page":"ComponentModel","title":"Carbon Time Series","text":"","category":"section"},{"location":"modules/componentmodel/","page":"ComponentModel","title":"ComponentModel","text":"# Create a carbon time series entry\ncarbon_ts = CarbonTimeSeries(\n    index = 1,\n    timestamp = DateTime(2025, 7, 8, 12, 0, 0),\n    grid_carbon_intensity_kgCO2e_per_MWh = 350.0,\n    renewable_generation_carbon_intensity_kgCO2e_per_MWh = 25.0,\n    storage_carbon_intensity_kgCO2e_per_MWh = 120.0\n)","category":"page"},{"location":"modules/componentmodel/#Carbon-Scenarios","page":"ComponentModel","title":"Carbon Scenarios","text":"","category":"section"},{"location":"modules/componentmodel/","page":"ComponentModel","title":"ComponentModel","text":"# Create a carbon scenario\ncarbon_scenario = CarbonScenario(\n    index = 1,\n    name = \"Net Zero 2050\",\n    description = \"Scenario aligned with net zero emissions by 2050\",\n    year = 2050,\n    grid_carbon_intensity_kgCO2e_per_MWh = 50.0,\n    renewable_penetration_percent = 85.0,\n    ev_adoption_percent = 95.0,\n    storage_capacity_mwh = 500000.0\n)","category":"page"},{"location":"modules/componentmodel/#Equipment-Carbon-Models","page":"ComponentModel","title":"Equipment Carbon Models","text":"","category":"section"},{"location":"modules/componentmodel/","page":"ComponentModel","title":"ComponentModel","text":"# Create an equipment carbon record\nequipment_carbon = EquipmentCarbon(\n    index = 1,\n    element_type = \"transformer\",\n    element_id = 101,\n    carbon_embodied_kgCO2e = 25000.0,\n    carbon_operational_kgCO2e_per_year = 500.0,\n    lifetime_years = 30,\n    manufacturing_date = Date(2023, 3, 15),\n    installation_date = Date(2023, 6, 10),\n    recycling_rate_percent = 75.0\n)","category":"page"},{"location":"modules/componentmodel/#Carbon-Reduction-Strategies","page":"ComponentModel","title":"Carbon Reduction Strategies","text":"","category":"section"},{"location":"modules/componentmodel/","page":"ComponentModel","title":"ComponentModel","text":"The carbon emission models support various strategies for reducing carbon emissions in power systems:","category":"page"},{"location":"modules/componentmodel/","page":"ComponentModel","title":"ComponentModel","text":"Equipment Replacement: Calculate the carbon payback period for replacing high-emission equipment.\nScenario Analysis: Compare system emissions under different future scenarios.\nTemporal Optimization: Schedule operations to minimize carbon emissions based on time-varying carbon intensities.","category":"page"},{"location":"modules/componentmodel/#Advanced-Applications","page":"ComponentModel","title":"Advanced Applications","text":"","category":"section"},{"location":"modules/componentmodel/","page":"ComponentModel","title":"ComponentModel","text":"ComponentModel components can be used for various power system analyses, including:","category":"page"},{"location":"modules/componentmodel/","page":"ComponentModel","title":"ComponentModel","text":"Power Flow Analysis: Determining voltage and power distribution under steady-state conditions\nFault Analysis: Assessing the impact of short-circuit faults on the system\nStability Analysis: Studying the dynamic behavior of the system following disturbances\nOptimal Dispatch: Determining the optimal output of generators to meet load demands\nHVDC Transmission: Long-distance bulk power transfer with minimal losses\nRenewable Integration: Connection of remote renewable energy sources to the grid\nMicrogrids: Formation of DC or hybrid AC/DC microgrids\nEnergy Storage: Integration of large-scale energy storage systems\nEnvironmental Impact Assessment: Evaluating carbon emissions and reduction strategies","category":"page"},{"location":"modules/componentmodel/","page":"ComponentModel","title":"ComponentModel","text":"For more advanced application examples, refer to the relevant sections in the user manual.","category":"page"},{"location":"api/utils/#API-Reference","page":"Utils API","title":"API Reference","text":"","category":"section"},{"location":"api/utils/#Input-Interface","page":"Utils API","title":"Input Interface","text":"","category":"section"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.load_ac_pv_system!-Tuple{JuliaPowerCase, String, String}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.load_ac_pv_system!","text":"load_ac_pv_system!(case::JuliaPowerCase, file_path::String, sheet_name::String)\n\nLoad AC PV system data from Excel file and add to power system case. Parameters:\n\ncase::JuliaPowerCase: Power system case\nfile_path::String: Excel file path\nsheet_name::String: Worksheet name containing AC PV system data\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.load_buses!-Tuple{JuliaPowerCase, String, String}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.load_buses!","text":"load_buses!(case::JuliaPowerCase, file_path::String, sheet_name::String)\n\nLoad bus data from Excel file and add to power system case. Also creates mappings from bus names to integer IDs and from zone names to integer IDs.\n\nParameters:\n\ncase::JuliaPowerCase: Power system case\nfile_path::String: Excel file path\nsheet_name::String: Worksheet name containing bus data\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.load_converters!-Tuple{JuliaPowerCase, String, String}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.load_converters!","text":"load_converters!(case::JuliaPowerCase, file_path::String, sheet_name::String)\n\nLoad converter data from Excel file and add to power system case.\n\nParameters:\n\ncase::JuliaPowerCase: Power system case\nfile_path::String: Excel file path\nsheet_name::String: Worksheet name containing converter data\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.load_dclines!-Tuple{JuliaPowerCase, String, String}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.load_dclines!","text":"load_dclines!(case::JuliaPowerCase, file_path::String, sheet_name::String)\n\nLoad DC line data from Excel file and add to power system case.\n\nParameters:\n\ncase::JuliaPowerCase: Power system case\nfile_path::String: Excel file path\nsheet_name::String: Worksheet name containing DC line data\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.load_dcloads!-Tuple{JuliaPowerCase, String, String}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.load_dcloads!","text":"load_dcloads!(case::JuliaPowerCase, file_path::String, sheet_name::String)\n\nLoad DC load data from Excel file and add to power system case.\n\nParameters:\n\ncase::JuliaPowerCase: Power system case\nfile_path::String: Excel file path\nsheet_name::String: Worksheet name containing DC load data\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.load_ext_grids!-Tuple{JuliaPowerCase, String, String}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.load_ext_grids!","text":"load_ext_grids!(case::JuliaPowerCase, file_path::String, sheet_name::String)\n\nLoad external grid data from Excel file and add to power system case.\n\nParameters:\n\ncase::JuliaPowerCase: Power system case\nfile_path::String: Excel file path\nsheet_name::String: Worksheet name containing external grid data\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.load_generators!-Tuple{JuliaPowerCase, String, String}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.load_generators!","text":"load_generators!(case::JuliaPowerCase, file_path::String, sheet_name::String)\n\nLoad generator data from Excel file and add to power system case.\n\nParameters:\n\ncase::JuliaPowerCase: Power system case\nfile_path::String: Excel file path\nsheet_name::String: Worksheet name containing generator data\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.load_julia_power_data-Tuple{String}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.load_julia_power_data","text":"load_julia_power_data(file_path::String)\n\nLoad power system data from an Excel file and convert it to a JuliaPowerCase structure.\n\nParameters:\n\nfile_path::String: Path to the Excel file\n\nReturns:\n\nJuliaPowerCase: Structure containing all power system components\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.load_lines!-Tuple{JuliaPowerCase, String, String}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.load_lines!","text":"load_lines!(case::JuliaPowerCase, file_path::String, sheet_name::String)\n\nLoad line data from Excel file and add to power system case. Uses case.busnameto_id to map bus names to integer IDs.\n\nParameters:\n\ncase::JuliaPowerCase: Power system case\nfile_path::String: Excel file path\nsheet_name::String: Worksheet name containing line data\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.load_loads!-Tuple{JuliaPowerCase, String, String}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.load_loads!","text":"load_loads!(case::JuliaPowerCase, file_path::String, sheet_name::String)\n\nLoad load data from Excel file and add to power system case.\n\nParameters:\n\ncase::JuliaPowerCase: Power system case\nfile_path::String: Excel file path\nsheet_name::String: Worksheet name containing load data\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.load_pv_arrays!-Tuple{JuliaPowerCase, String, String}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.load_pv_arrays!","text":"load_pv_arrays!(case::JuliaPowerCase, file_path::String, sheet_name::String)\n\nLoad PV array data from Excel file and add to power system case. Parameters:\n\ncase::JuliaPowerCase: Power system case\nfile_path::String: Excel file path\nsheet_name::String: Worksheet name containing PV array data\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.load_static_generators!-Tuple{JuliaPowerCase, String, String}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.load_static_generators!","text":"load_static_generators!(case::JuliaPowerCase, file_path::String, sheet_name::String)\n\nLoad static generator data from Excel file and add to power system case.\n\nParameters:\n\ncase::JuliaPowerCase: Power system case\nfile_path::String: Excel file path\nsheet_name::String: Worksheet name containing static generator data\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.load_storages!-Tuple{JuliaPowerCase, String, String}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.load_storages!","text":"load_storages!(case::JuliaPowerCase, file_path::String, sheet_name::String)\n\nLoad energy storage device data from Excel file and add to power system case.\n\nParameters:\n\ncase::JuliaPowerCase: Power system case\nfile_path::String: Excel file path\nsheet_name::String: Worksheet name containing energy storage device data\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.load_switches!-Tuple{JuliaPowerCase, String, String}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.load_switches!","text":"load_switches!(case::JuliaPowerCase, file_path::String, sheet_name::String)\n\nLoad switch data from Excel file and add to power system case.\n\nParameters:\n\ncase::JuliaPowerCase: Power system case\nfile_path::String: Excel file path\nsheet_name::String: Worksheet name containing switch data\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.load_trafo!-Tuple{JuliaPowerCase, String, String}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.load_trafo!","text":"load_trafo!(case::JuliaPowerCase, file_path::String, sheet_name::String)\n\nLoad two-winding transformer data from Excel file and add to power system case.\n\nParameters:\n\ncase::JuliaPowerCase: Power system case\nfile_path::String: Excel file path\nsheet_name::String: Worksheet name containing two-winding transformer data\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.load_trafo3ws!-Tuple{JuliaPowerCase, String, String}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.load_trafo3ws!","text":"load_trafo3ws!(case::JuliaPowerCase, file_path::String, sheet_name::String)\n\nLoad three-winding transformer data from Excel file and add to power system case.\n\nParameters:\n\ncase::JuliaPowerCase: Power system case\nfile_path::String: Excel file path\nsheet_name::String: Worksheet name containing three-winding transformer data\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.load_virtual_power_plants!-Tuple{JuliaPowerCase, String, String}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.load_virtual_power_plants!","text":"load_virtual_power_plants!(case::JuliaPowerCase, file_path::String, sheet_name::String)\n\nLoad virtual power plant (VPP) data from Excel file and add to power system case.\n\nParameters:\n\ncase::JuliaPowerCase: Power system case\nfile_path::String: Excel file path\nsheet_name::String: Worksheet name containing virtual power plant data\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.validate_case-Tuple{JuliaPowerCase}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.validate_case","text":"validate_case(case::JuliaPowerCase)\n\nValidate the integrity and consistency of the loaded power system case data.\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#Data-Structure","page":"Utils API","title":"Data Structure","text":"","category":"section"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC","text":"Definition of the JPC structure as one matrix format.\nThis structure represents a power system case in a one matrix format,\nincluding buses, generators, branches, loads, and other power system components.\nEach matrix is sized according to the number of attributes defined in idx.jl.\n\n\n\n\n\n","category":"type"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_3ph","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_3ph","text":"Definition of the JPC_3ph structure for three-phase power flow analysis.\nThis structure extends the JPC format to support three-phase power flow calculations.\n\n\n\n\n\n","category":"type"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JuliaPowerCase","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JuliaPowerCase","text":"Definition of the power flow problem structure.\nAligned with JPC structure for consistency.\n\n\n\n\n\n","category":"type"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.MicrogridPlanningProblem","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.MicrogridPlanningProblem","text":"Definition of the Microgrid Planning Problem structure.    This structure contains all parameters and variables for microgrid planning optimization.\n\n\n\n\n\n","category":"type"},{"location":"api/utils/#Base.getindex-Tuple{HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_3ph, String}","page":"Utils API","title":"Base.getindex","text":"getindex(jpc::JPC_3ph, key::String)\n\nAccess JPC_3ph components by string key.\n\nArguments\n\njpc: JPC_3ph structure\nkey: String key representing the component to access\n\nReturns\n\nThe requested component data\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#Base.getindex-Tuple{JPC, String}","page":"Utils API","title":"Base.getindex","text":"getindex(jpc::JPC, key::String)\n\nAccess JPC components by string key.\n\nArguments\n\njpc: JPC structure\nkey: String key representing the component to access\n\nReturns\n\nThe requested component data\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#Base.setindex!-Tuple{HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_3ph, Any, String}","page":"Utils API","title":"Base.setindex!","text":"setindex!(jpc::JPC_3ph, value, key::String)\n\nSet JPC_3ph components by string key.\n\nArguments\n\njpc: JPC_3ph structure\nvalue: Value to assign\nkey: String key representing the component to modify\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#Base.setindex!-Tuple{JPC, Any, String}","page":"Utils API","title":"Base.setindex!","text":"setindex!(jpc::JPC, value, key::String)\n\nSet JPC components by string key.\n\nArguments\n\njpc: JPC structure\nvalue: Value to assign\nkey: String key representing the component to modify\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#Inner-Interface","page":"Utils API","title":"Inner Interface","text":"","category":"section"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_ac_pv_system_process-Tuple{JuliaPowerCase, JPC}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_ac_pv_system_process","text":"JPC_ac_pv_system_process(case::JuliaPowerCase, jpc::JPC)\n\nProcesses AC-side photovoltaic (PV) systems from a JuliaPowerCase and converts them to JPC format.\n\nThis function extracts information about AC-connected PV systems from the input case, performs necessary calculations to determine their electrical characteristics, and stores the processed data in the JPC structure.\n\nFor each AC-side PV system, the function:\n\nCalculates operating voltages and currents based on panel configuration and conditions:\nMaximum power point voltage (Vmpp) adjusted for series-connected panels\nOpen-circuit voltage (Voc) adjusted for temperature and series connections\nShort-circuit current (Isc) adjusted for temperature, irradiance, and parallel connections\nMaximum power point current (Impp) adjusted for parallel-connected panels\nCalculates maximum power output accounting for system losses\nDetermines the control mode (Voltage Control or MVar Control)\nStores all parameters in a standardized matrix format\n\nThe function performs the following steps:\n\nFilters the input case to identify in-service AC-side PV systems\nIf no in-service systems exist, returns the JPC object unchanged\nCreates a matrix to store PV system data\nFor each PV system:\nCalculates electrical parameters based on environmental conditions\nSets control mode flags\nPopulates the matrix with all required parameters\nAdds the processed PV system data to the JPC object's pv_acsystem field\n\nArguments\n\ncase::JuliaPowerCase: The original power system case containing AC-side PV system data\njpc::JPC: The JPC object where the processed PV system data will be stored\n\nReturns\n\nThe updated JPC object with AC-side PV system data in the pv_acsystem field\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_battery_branch_process-Tuple{JuliaPowerCase, JPC}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_battery_branch_process","text":"JPC_battery_branch_process(case::JuliaPowerCase, jpc::JPC)\n\nProcesses battery storage branches from a JuliaPowerCase and converts them to JPC format.\n\nThis function creates DC branch connections between virtual battery buses and their  corresponding actual buses in the power system. Each battery is represented as a DC branch with the following characteristics:\n\nFrom bus: Virtual battery bus (created in JPCbatterybus_process)\nTo bus: Actual bus where the battery is physically connected\nBranch resistance: Calculated from battery internal resistance in per unit\nBranch reactance: Set to 0 (DC branches have no reactance)\nBranch rating: Based on battery package size and open-circuit voltage\nBranch status: 1.0 if in service, 0.0 if not\nAngle limits: Set to -360° and 360°\n\nThe function performs the following steps:\n\nCreates a deep copy of the battery storage data\nIf no batteries exist, returns the JPC object unchanged\nInitializes a matrix to store battery branch data\nFor each battery:\nIdentifies the actual bus where the battery is connected\nCalculates the virtual bus ID for the battery\nRetrieves the base voltage from the actual bus\nCalculates the per unit resistance using the base impedance\nSets all branch parameters including status and ratings\nAppends the processed battery branch data to the JPC object's branchDC field\n\nArguments\n\ncase::JuliaPowerCase: The original power system case containing battery storage data\njpc::JPC: The JPC object where the battery branch data will be added\n\nReturns\n\nThe updated JPC object with battery branches added to the branchDC field\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_battery_bus_process-Tuple{JuliaPowerCase, JPC}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_battery_bus_process","text":"JPC_battery_bus_process(case::JuliaPowerCase, jpc::JPC)\n\nProcesses battery storage data from a JuliaPowerCase and creates virtual DC buses for them in the JPC format.\n\nThis function extracts battery storage information from the input case, creates virtual DC buses to represent the batteries in the power system model, and appends these buses to the existing DC bus matrix in the JPC object.\n\nEach battery is represented as a virtual DC bus with the following characteristics:\n\nBus ID assigned sequentially after existing DC buses\nBus type set to PV node (value 2.0)\nNo initial power demand or generation\nVoltage magnitude initialized to 1.0 p.u.\nVoltage angle initialized to 0.0 degrees\nBase voltage set to the battery's open-circuit voltage\nArea and zone IDs set to 1.0\nVoltage limits set to 0.95 (min) and 1.05 (max) p.u.\n\nArguments\n\ncase::JuliaPowerCase: The original power system case containing battery storage data\njpc::JPC: The JPC object where the virtual battery buses will be added\n\nReturns\n\nThe updated JPC object with virtual battery buses added to the busDC field\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_battery_gens_process-Tuple{JuliaPowerCase, JPC}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_battery_gens_process","text":"JPC_battery_gens_process(case::JuliaPowerCase, jpc::JPC)\n\nProcess battery storage devices and create virtual generators for them in the JPC structure.\n\nThis function creates virtual generators to represent battery storage devices in the power system model. Each battery is assigned a virtual bus and corresponding generator parameters based on its characteristics.\n\nThe function performs the following steps:\n\nMakes a deep copy of the storage devices from the input case\nIf no batteries exist, returns without modifications\nDetermines virtual node numbers based on the current busDC matrix size\nCreates matrices for battery generators and storage information\nFor each battery:\nAssigns a virtual bus number\nCalculates power capacity based on battery parameters\nSets generator parameters (power limits, voltage setpoint, status, etc.)\nConfigures storage-specific parameters\nAdds the battery generators to the JPC's genDC field\nAdds the storage information to the JPC's storageetap field\n\nArguments\n\ncase::JuliaPowerCase: The original power system case containing battery storage data\njpc::JPC: The JPC object where the virtual generators will be added\n\nReturns\n\nThe updated JPC object with battery virtual generators added to genDC and storage information added to storageetap\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_battery_soc_process-Tuple{JuliaPowerCase, JPC}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_battery_soc_process","text":"JPC_battery_soc_process(case::JuliaPowerCase, jpc::JPC)\n\nProcesses battery state of charge (SOC) data from a JuliaPowerCase and converts it to JPC format.\n\nThis function extracts battery storage information from the input case and creates two data structures:\n\nA battery SOC matrix containing parameters related to battery energy storage capabilities\nLoad entries in the loadDC matrix to represent battery connections to the power system\n\nFor each battery, the following SOC parameters are stored:\n\nBus ID where the battery is connected\nPower capacity in MW (maximum charge/discharge rate)\nEnergy capacity in MWh\nInitial state of charge (SOC)\nMinimum allowable SOC\nMaximum allowable SOC\nRound-trip efficiency (0.0-1.0)\nStatus indicator (1.0 if in service, 0.0 if not)\n\nAdditionally, for each battery, the function:\n\nCreates a corresponding load entry in the loadDC matrix\nSets the load ID, bus index, and status parameters\nInitializes power values to zero\n\nThe function performs the following steps:\n\nCreates a deep copy of the battery storage data\nIf no batteries exist, returns the JPC object unchanged\nInitializes a matrix to store battery SOC data\nPopulates the SOC matrix with battery parameters\nFor each battery, creates a corresponding load entry in the loadDC matrix\nAdds the processed battery SOC data to the JPC object's storage field\n\nArguments\n\ncase::JuliaPowerCase: The original power system case containing battery storage data\njpc::JPC: The JPC object where the battery SOC data will be stored\n\nReturns\n\nThe updated JPC object with battery SOC data in the storage field and corresponding load entries in the loadDC field\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_branches_process-Tuple{JuliaPowerCase, JPC}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_branches_process","text":"JPC_branches_process(case::JuliaPowerCase, jpc::JPC)\n\nProcesses AC branch data from a JuliaPowerCase and converts it to JPC format.\n\nThis function handles the calculation and conversion of various branch elements  in the power system to the format required by JPC. It processes:\n\nAC transmission lines by calling calculatelineparameters()\nTwo-winding transformers by calling calculatetransformer2wparameters()\n\nThe function is structured to potentially handle different sequence components (positive, negative, zero), though the conditional logic for sequence selection is currently commented out. In its current implementation, it processes only the positive sequence components.\n\nNote: The commented code suggests that for sequence 1 or 2 (positive or negative sequence), the function processes lines and transformers with their standard parameters, while for sequence 0 (zero sequence), it would call a different function (calculatebranchJPC_zero).\n\nArguments\n\ncase::JuliaPowerCase: The original power system case containing branch data\njpc::JPC: The JPC object where the processed branch data will be stored\n\nReturns\n\nThe updated JPC object with branch data processed (implicitly, as the jpc object is modified in place)\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_buses_process-Tuple{JuliaPowerCase, JPC}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_buses_process","text":"JPC_buses_process(case::JuliaPowerCase, jpc::JPC)\n\nProcesses AC bus data from a JuliaPowerCase and converts it to JPC format.\n\nThis function extracts AC bus information from the input case, transforms it into  the standard matrix format required by JPC, and stores it in the JPC object. Each bus is represented as a row in the matrix with the following columns:\n\nBus ID\nBus type (all initialized as PQ nodes with value 1.0)\nActive power demand (PD) in MW (initialized to 0.0)\nReactive power demand (QD) in MVAR (initialized to 0.0)\nActive power shunt conductance (GS) in MW (initialized to 0.0)\nReactive power shunt susceptance (BS) in MVAR (initialized to 0.0)\nArea ID\nVoltage magnitude (VM) in p.u. (initialized to 1.0)\nVoltage angle (VA) in degrees (initialized to 0.0)\nBase voltage (VN) in kV\nZone ID\nMaximum voltage magnitude in p.u.\nMinimum voltage magnitude in p.u.\n\nArguments\n\ncase::JuliaPowerCase: The original power system case containing bus data\njpc::JPC: The JPC object where the processed bus data will be stored\n\nReturns\n\nThe updated JPC object with the busAC field populated\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_dcbranches_process-Tuple{JuliaPowerCase, JPC}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_dcbranches_process","text":"JPC_dcbranches_process(case::JuliaPowerCase, jpc::JPC)\n\nProcesses DC branch data from a JuliaPowerCase and converts it to JPC format.\n\nThis function extracts DC branch information from the input case, transforms it into  the standard matrix format required by JPC, and stores it in the JPC object. Each DC branch is represented as a row in the matrix with the following columns:\n\nFrom bus index (F_BUS)\nTo bus index (T_BUS)\nBranch resistance in p.u. (BR_R) - calculated from length and ohms/km\nBranch reactance in p.u. (BR_X) - set to 0 for DC branches\nBranch rating in MVA (RATE_A) - calculated from max current or set to default\nBranch status (BR_STATUS) - 1.0 if in service, 0.0 if not\n\n7-14. Various parameters including angle limits (ANGMIN, ANGMAX)\n\nThe function performs the following steps:\n\nInitializes a matrix to store DC branch data\nFor each DC branch in the case:\nIdentifies the from and to bus indices\nCalculates the base impedance using the from bus base voltage\nConverts resistance from ohms to per unit values\nSets the branch parameters including status and ratings\nSets angle limits to -360° and 360°\nAppends the processed branch data to the JPC object\nProcesses battery branches by calling JPCbatterybranch_process\n\nArguments\n\ncase::JuliaPowerCase: The original power system case containing DC branch data\njpc::JPC: The JPC object where the processed DC branch data will be stored\n\nReturns\n\nThe updated JPC object with the branchDC field populated and battery branch data processed\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_dcbuses_process-Tuple{Any, Any}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_dcbuses_process","text":"JPC_dcbuses_process(case::JuliaPowerCase, jpc::JPC)\n\nProcesses DC bus data from a JuliaPowerCase and converts it to JPC format.\n\nThis function extracts DC bus information from the input case, transforms it into  the standard matrix format required by JPC, and stores it in the JPC object. Each DC bus is represented as a row in the matrix with the following columns:\n\nBus ID\nBus type (all initialized as PQ nodes with value 1.0)\nActive power demand (PD) in MW (initialized to 0.0)\nReactive power demand (QD) in MVAR (initialized to 0.0)\nActive power shunt conductance (GS) in MW (initialized to 0.0)\nReactive power shunt susceptance (BS) in MVAR (initialized to 0.0)\nArea ID\nVoltage magnitude (VM) in p.u. (initialized to 1.0)\nVoltage angle (VA) in degrees (initialized to 0.0)\nBase voltage (VN) in kV\nZone ID\nMaximum voltage magnitude in p.u.\nMinimum voltage magnitude in p.u.\n\nAfter processing the basic DC bus data, this function also calls JPCbatterybus_process to handle battery-specific bus information.\n\nArguments\n\ncase::JuliaPowerCase: The original power system case containing DC bus data\njpc::JPC: The JPC object where the processed DC bus data will be stored\n\nReturns\n\nThe updated JPC object with the busDC field populated and battery bus data processed\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_dcloads_process-Tuple{JuliaPowerCase, JPC}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_dcloads_process","text":"JPC_dcloads_process(case::JuliaPowerCase, jpc::JPC)\n\nProcess DC load data from a JuliaPowerCase and convert it to JPC format.\n\nThis function extracts information about DC loads from the input case, applies scaling factors, and stores the processed data in the JPC structure. It also updates the power demand values in the corresponding DC bus data.\n\nFor each DC load, the function:\n\nRecords its basic properties (index, bus connection)\nCalculates active power demand with scaling applied\nStores load model composition (ZIP model percentages)\nUpdates the connected DC bus with the additional power demand\n\nThe function performs the following steps:\n\nFilters the input case to identify in-service DC loads\nIf no in-service loads exist, returns without modifications\nCreates a matrix to store DC load data with 8 columns\nFor each DC load:\nPopulates the matrix with all required parameters\nUpdates the corresponding bus data with the load's power demand\nAdds the processed DC load data to the JPC object's loadDC field\n\nArguments\n\ncase::JuliaPowerCase: The original power system case containing DC load data\njpc::JPC: The JPC object where the processed DC load data will be stored\n\nReturns\n\nThe updated JPC object with DC load data in the loadDC field and updated busDC power demands\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_gens_process-Tuple{JuliaPowerCase, JPC}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_gens_process","text":"JPC_gens_process(case::JuliaPowerCase, jpc::JPC)\n\nProcess generator data from a JuliaPowerCase and convert it to JPC format.\n\nThis function processes three types of generation devices:\n\nExternal grids (typically serving as slack/reference nodes)\nConventional generators (typically serving as PV nodes)\nStatic generators (typically serving as PQ nodes, but can be PV nodes if controllable)\n\nFor each generation device, the function:\n\nExtracts its parameters from the input case\nConverts them to the format required by JPC\nAssigns appropriate bus types based on generator characteristics\nEnsures proper handling of power outputs, limits, and ramp rates\n\nThe function performs the following steps:\n\nCounts the number of each type of generation device\nCreates a matrix to store generator data with 26 columns\nProcesses each type of generator and populates the matrix\nUpdates bus types in the JPC structure based on generator connections\nRemoves entries for out-of-service generators\nEnsures at least one slack node exists in the system\n\nArguments\n\ncase::JuliaPowerCase: The original power system case containing generator data\njpc::JPC: The JPC object where the processed generator data will be stored\n\nReturns\n\nNone. The JPC object is modified in-place.\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_inverters_process-Tuple{JuliaPowerCase, JPC}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_inverters_process","text":"JPC_inverters_process(case::JuliaPowerCase, jpc::JPC)\n\nProcess converters/inverters from a JuliaPowerCase and integrate them into the JPC format.\n\nThis function handles the conversion of power electronic converters (inverters) from the  JuliaPowerCase format to the JPC format, updating the relevant bus types and power flow parameters according to each inverter's control mode.\n\nFor each in-service inverter, the function:\n\nDetermines the control mode and sets appropriate flags\nCalculates AC and DC side power flows considering efficiency losses\nUpdates bus types for both AC and DC sides based on control mode\nCreates generator entries when needed for voltage control\nUpdates load records for power injection/consumption\nHandles ZIP load model parameters through weighted averaging\n\nThe function supports the following control modes:\n\nδs_Us: Slack bus on AC side, P node on DC side\nPs_Qs: PQ node on AC side, P node on DC side\nPs_Us: PV node on AC side, P node on DC side\nUdc_Qs: PQ node on AC side, slack node on DC side\nUdc_Us: PV node on AC side, slack node on DC side\nDroopUdcQs: PQ node on AC side with droop control, slack node on DC side\nDroopUdcUs: PV node on AC side with droop control, slack node on DC side\n\nArguments\n\ncase::JuliaPowerCase: The original power system case containing converter data\njpc::JPC: The JPC object where the processed converter data will be stored\n\nReturns\n\nThe updated JPC object with converter data integrated into the appropriate fields\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_loads_process-Tuple{JuliaPowerCase, JPC}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_loads_process","text":"JPC_loads_process(case::JuliaPowerCase, jpc::JPC)\n\nProcess AC load data from a JuliaPowerCase and convert it to JPC format.\n\nThis function extracts information about AC loads from the input case, applies scaling factors, and stores the processed data in the JPC structure. It also updates the power demand values in the corresponding AC bus data.\n\nFor each AC load, the function:\n\nRecords its basic properties (index, bus connection)\nCalculates active and reactive power demand with scaling applied\nStores load model composition (ZIP model percentages)\nAccumulates loads connected to the same bus\n\nThe function performs the following steps:\n\nFilters the input case to identify in-service AC loads\nIf no in-service loads exist, returns without modifications\nCreates a matrix to store AC load data with 8 columns\nFor each AC load:\nCalculates actual power demand with scaling applied\nPopulates the matrix with all required parameters\nAccumulates loads by bus connection\nAdds the processed AC load data to the JPC object's loadAC field\nUpdates the busAC matrix with the accumulated load values for each bus\n\nArguments\n\ncase::JuliaPowerCase: The original power system case containing AC load data\njpc::JPC: The JPC object where the processed AC load data will be stored\n\nReturns\n\nNone. The JPC object is modified in-place.\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_pv_process-Tuple{JuliaPowerCase, JPC}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_pv_process","text":"JPC_pv_process(case::JuliaPowerCase, jpc::JPC)\n\nProcess photovoltaic (PV) array data from a JuliaPowerCase and convert it to JPC format.\n\nThis function extracts information about PV arrays from the input case, performs necessary calculations to determine their electrical characteristics based on environmental conditions, and stores the processed data in the JPC structure.\n\nFor each PV array, the function:\n\nCalculates key electrical parameters adjusted for environmental conditions:\nOpen-circuit voltage (Voc) adjusted for temperature and series connections\nMaximum power point voltage (Vmpp) adjusted for series-connected panels\nShort-circuit current (Isc) adjusted for temperature, irradiance, and parallel connections\nMaximum power point current (Impp) adjusted for irradiance and parallel-connected panels\nStores all parameters in a standardized matrix format\n\nThe function performs the following steps:\n\nFilters the input case to identify in-service PV arrays\nIf no in-service arrays exist, returns without modifications\nCreates a matrix to store PV array data with 9 columns\nFor each PV array:\nCalculates electrical parameters based on temperature and irradiance conditions\nPopulates the matrix with all required parameters\nAdds the processed PV array data to the JPC object's pv field\n\nArguments\n\ncase::JuliaPowerCase: The original power system case containing PV array data\njpc::JPC: The JPC object where the processed PV array data will be stored\n\nReturns\n\nThe updated JPC object with PV array data in the pv field\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JuliaPowerCase2Jpc-Tuple{JuliaPowerCase}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JuliaPowerCase2Jpc","text":"JuliaPowerCase2Jpc(case::Utils.JuliaPowerCase)\n\nConverts a JuliaPowerCase object to a JPC (Julia Power Case) format for power flow analysis.\n\nThis function performs a complete transformation of the power system case data, processing all components and preparing them for power flow calculations. The conversion process includes:\n\nMerging virtual nodes to ensure a proper network topology\nCreating and populating a new JPC object with the following data:\nBasic parameters (base MVA)\nAC buses\nDC buses\nAC branches (lines and transformers)\nDC branches\nAC generators\nBattery systems (as DC generators)\nBattery state of charge data\nAC loads\nDC loads\nPV array data\nInverters (AC/DC converters)\nAC-connected PV systems\n\nArguments\n\ncase::Utils.JuliaPowerCase: The original power system case data\n\nReturns\n\nA fully populated JPC object ready for power flow analysis\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.calculate_line_parameters-Tuple{JuliaPowerCase, JPC}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.calculate_line_parameters","text":"JPCbatterysoc_process(case::JuliaPowerCase, jpc::JPC) Processes battery state of charge (SOC) data from a JuliaPowerCase and converts it to JPC format. This function extracts battery storage information from the input case and creates two data structures:\n\nA battery SOC matrix containing parameters related to battery energy storage capabilities Load entries in the loadDC matrix to represent battery connections to the power system\n\nFor each battery, the following SOC parameters are stored:\n\nBus ID where the battery is connected Power capacity in MW (maximum charge/discharge rate) Energy capacity in MWh Initial state of charge (SOC) Minimum allowable SOC Maximum allowable SOC Round-trip efficiency (0.0-1.0) Status indicator (1.0 if in service, 0.0 if not)\n\nAdditionally, for each battery, the function:\n\nCreates a corresponding load entry in the loadDC matrix Sets the load ID, bus index, and status parameters Initializes power values to zero\n\nThe function performs the following steps:\n\nCreates a deep copy of the battery storage data If no batteries exist, returns the JPC object unchanged Initializes a matrix to store battery SOC data Populates the SOC matrix with battery parameters For each battery, creates a corresponding load entry in the loadDC matrix Adds the processed battery SOC data to the JPC object's storage field\n\nArguments\n\ncase::JuliaPowerCase: The original power system case containing battery storage data jpc::JPC: The JPC object where the battery SOC data will be stored\n\nReturns The updated JPC object with battery SOC data in the storage field and corresponding load entries in the loadDC field\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.calculate_transformer2w_parameters-Tuple{JuliaPowerCase, JPC}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.calculate_transformer2w_parameters","text":"calculate_transformer2w_parameters(case::JuliaPowerCase, jpc::JPC)\n\nProcesses two-winding transformer data from a JuliaPowerCase and converts it to JPC format.\n\nThis function extracts two-winding transformer information from the input case and creates branch entries in the JPC object to represent transformers in the power system model.\n\nFor each transformer, the following parameters are calculated and stored:\n\nFrom bus (high voltage side) and to bus (low voltage side) indices\nPer-unit resistance and reactance values, adjusted to system base\nShunt susceptance (typically zero for transformers)\nTap ratio and phase shift angle\nPower rating and operational status\nAngle limits\n\nThe function performs the following steps:\n\nExtracts two-winding transformer data from the input case\nIf no transformers exist, returns without modification\nCreates a branch matrix to store transformer parameters\nFor each transformer:\nIdentifies the high and low voltage bus connections\nCalculates impedance parameters based on transformer specifications\nAdjusts values for the system base power\nAccounts for parallel transformers if present\nSets default values for tap ratio, phase shift, and other parameters\nAdds the transformer branch data to the JPC object's branchAC field\n\nArguments\n\ncase::JuliaPowerCase: The original power system case containing transformer data\njpc::JPC: The JPC object where the transformer branch data will be stored\n\nReturns\n\nThe updated JPC object with transformer data added to the branchAC field\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.merge_virtual_nodes-Tuple{JuliaPowerCase}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.merge_virtual_nodes","text":"merge_virtual_nodes(case::JuliaPowerCase)\n\nMerges virtual nodes in a power system case and updates all connected elements.\n\nThis function identifies virtual nodes (nodes with \"_虚拟节点\" in their name),  merges them with their connected real nodes, and updates all references in the system. The process includes:\n\nIdentifying virtual nodes and their connections\nCreating a mapping strategy for node merging\nUpdating all elements (lines, transformers, circuit breakers, loads, generators)\nRemoving virtual nodes and their associated circuit breakers\nMerging loads connected to the same bus after node consolidation\n\nArguments\n\ncase::JuliaPowerCase: The original power system case\n\nReturns\n\nA new JuliaPowerCase with virtual nodes merged and all references updated\n\nNote\n\nVirtual nodes are identified by the substring \"_虚拟节点\" in their names\nAt least two connections are required for a virtual node to be merged\nSelf-loops created during merging are disabled\nLoads at the same bus after merging are consolidated into a single load\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.resolve_node_mapping-Tuple{Any, Any}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.resolve_node_mapping","text":"resolve_node_mapping(node_id, node_merge_map)\n\nResolves the final mapping of a node by traversing through a node merge map.\n\nThis function follows the chain of node mappings to find the final destination node. It handles multiple levels of redirection by iteratively looking up each node ID in the mapping until it finds a node that doesn't have a further mapping.\n\nArguments\n\nnode_id: The initial node ID to resolve\nnode_merge_map: A dictionary mapping source nodes to destination nodes\n\nReturns\n\nThe final resolved node ID after following all mappings\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_3ph_add_grid_external_sc_impedance-Tuple{JuliaPowerCase, HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_3ph, Int64}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_3ph_add_grid_external_sc_impedance","text":"JPC_3ph_add_grid_external_sc_impedance(case::JuliaPowerCase, jpc_3ph::Utils.JPC_3ph, sequence::Int)\n\nAdd external grid short circuit impedance to the appropriate sequence component.\n\nThis function calculates and adds short circuit impedance for external grids to the specified sequence component. For positive sequence (sequence=1), no additional impedance is added. For negative (sequence=2) and zero (sequence=0) sequences, short circuit impedance is added as shunt admittance to the connected buses.\n\nArguments\n\ncase::JuliaPowerCase: The power system case data\njpc_3ph::Utils.JPC_3ph: The three-phase JPC object\nsequence::Int: Sequence component identifier (0=zero, 1=positive, 2=negative)\n\nReturns\n\njpc_3ph::Utils.JPC_3ph: The updated JPC_3ph object\ngs_eg::Vector{Float64}: Conductance values for external grids (only for sequence=2)\nbs_eg::Vector{Float64}: Susceptance values for external grids (only for sequence=2)\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_3ph_branches_process-Tuple{JuliaPowerCase, HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_3ph}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_3ph_branches_process","text":"JPC_3ph_branches_process(case::JuliaPowerCase, jpc_3ph::Utils.JPC_3ph)\n\nProcess branch data from a JuliaPowerCase and populate the JPC_3ph object with sequence component branch data.\n\nThis function calculates parameters for lines and transformers for all sequence components (positive, negative, and zero).\n\nArguments\n\ncase::JuliaPowerCase: The power system case data\njpc_3ph::Utils.JPC_3ph: The three-phase JPC object to be populated\n\nReturns\n\njpc_3ph::Utils.JPC_3ph: The updated JPC_3ph object with branch data\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_3ph_buses_process-Tuple{JuliaPowerCase, HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_3ph}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_3ph_buses_process","text":"JPC_3ph_buses_process(case::JuliaPowerCase, jpc_3ph::Utils.JPC_3ph)\n\nProcess bus data from a JuliaPowerCase and populate the JPC_3ph object with sequence component bus data.\n\nThis function creates bus matrices for positive, negative, and zero sequence components. For positive sequence, voltage magnitude is initialized to 1.0 p.u., while for negative and  zero sequence components, voltage magnitude is initialized to 0.0 p.u.\n\nArguments\n\ncase::JuliaPowerCase: The power system case data\njpc_3ph::Utils.JPC_3ph: The three-phase JPC object to be populated\n\nReturns\n\njpc_3ph::Utils.JPC_3ph: The updated JPC_3ph object with bus data\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_3ph_gens_process-Tuple{JuliaPowerCase, HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_3ph}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_3ph_gens_process","text":"JPC_3ph_gens_process(case::JuliaPowerCase, jpc_3ph::Utils.JPC_3ph)\n\nProcess generator data from a JuliaPowerCase and populate the JPC_3ph object with sequence component generator data.\n\nThis function handles different types of generators including conventional generators, static generators, and external grids. It also sets appropriate bus types (PQ, PV, or reference) based on the generators.\n\nArguments\n\ncase::JuliaPowerCase: The power system case data\njpc_3ph::Utils.JPC_3ph: The three-phase JPC object to be populated\n\nSide effects\n\nUpdates jpc_3ph.genAC_1, jpc_3ph.genAC_2, and jpc_3ph.genAC_0 with generator data\nUpdates bus types in jpc_3ph.busAC_1, jpc_3ph.busAC_2, and jpc_3ph.busAC_0\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_3ph_loads_process-Tuple{JuliaPowerCase, HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_3ph}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_3ph_loads_process","text":"JPC_3ph_loads_process(case::JuliaPowerCase, jpc_3ph::Utils.JPC_3ph)\n\nProcess load data from a JuliaPowerCase and populate the JPC_3ph object with sequence component load data.\n\nThis function handles different types of loads (wye and delta connected) and distributes their power appropriately across sequence components. For balanced loads, only positive sequence components have non-zero values.\n\nArguments\n\ncase::JuliaPowerCase: The power system case data\njpc_3ph::Utils.JPC_3ph: The three-phase JPC object to be populated\n\nSide effects\n\nUpdates jpc_3ph.loadAC_1, jpc_3ph.loadAC_2, and jpc_3ph.loadAC_0 with load data\nUpdates PD and QD fields in bus matrices for all sequence components\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JuliaPowerCase2Jpc_3ph-Tuple{JuliaPowerCase}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JuliaPowerCase2Jpc_3ph","text":"JuliaPowerCase2Jpc_3ph(case::JuliaPowerCase)\n\nConvert a JuliaPowerCase object to a three-phase JPC_3ph object.\n\nThis function processes a power system case in JuliaPowerCase format and converts it into a three-phase sequence component model (JPC_3ph) for three-phase power flow analysis.\n\nArguments\n\ncase::JuliaPowerCase: The power system case data in JuliaPowerCase format\n\nReturns\n\njpc_3ph::JPC_3ph: The converted three-phase power system model\ngs_eg::Vector{Float64}: Conductance values for external grids\nbs_eg::Vector{Float64}: Susceptance values for external grids\n\nProcess\n\nMerges virtual nodes\nCreates a new JPC_3ph object\nSets base parameters\nProcesses bus data for all sequence components\nProcesses branch data for all sequence components\nProcesses generator data for all sequence components\nProcesses load data for all sequence components\nAdds external grid short circuit impedance data\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.add_line_sc_impedance_zero-Tuple{JuliaPowerCase, HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_3ph, Any}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.add_line_sc_impedance_zero","text":"add_line_sc_impedance_zero(case::JuliaPowerCase, jpc_3ph::Utils.JPC_3ph, branch)\n\nAdd zero sequence impedance parameters for lines to the branch matrix.\n\nThis function calculates and adds zero sequence parameters for transmission lines. If specific zero sequence data is not available, it approximates using positive sequence data.\n\nArguments\n\ncase::JuliaPowerCase: The power system case data\njpc_3ph::Utils.JPC_3ph: The three-phase JPC object\nbranch: The branch matrix to be updated with zero sequence parameters\n\nReturns\n\nUpdated branch matrix with zero sequence line parameters\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.add_trafo_sc_impedance_zero-Tuple{JuliaPowerCase, HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_3ph, Any}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.add_trafo_sc_impedance_zero","text":"add_trafo_sc_impedance_zero(case::JuliaPowerCase, jpc_3ph::Utils.JPC_3ph, branch)\n\nAdd zero sequence impedance parameters for transformers to the branch matrix.\n\nThis function calculates and adds zero sequence parameters for two-winding transformers, considering different transformer vector groups (winding connections). For some connections, transformers are represented as shunt admittances rather than branches in the zero sequence network.\n\nArguments\n\ncase::JuliaPowerCase: The power system case data\njpc_3ph::Utils.JPC_3ph: The three-phase JPC object\nbranch: The branch matrix to be updated with zero sequence parameters\n\nReturns\n\nUpdated branch matrix with zero sequence transformer parameters\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.calculate_3ph_line_parameters-Tuple{JuliaPowerCase, HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_3ph}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.calculate_3ph_line_parameters","text":"calculate_3ph_line_parameters(case::JuliaPowerCase, jpc_3ph::Utils.JPC_3ph)\n\nCalculate line parameters for positive and negative sequence components.\n\nThis function processes line data from a JuliaPowerCase and converts it to JPC format for both positive and negative sequence components. For most lines, negative sequence parameters are equal to positive sequence parameters.\n\nArguments\n\ncase::JuliaPowerCase: The power system case data\njpc_3ph::Utils.JPC_3ph: The three-phase JPC object to be populated\n\nSide effects\n\nUpdates jpc_3ph.branchAC_1 (positive sequence) and jpc_3ph.branchAC_2 (negative sequence)\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.calculate_3ph_transformer2w_parameters-Tuple{JuliaPowerCase, HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_3ph}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.calculate_3ph_transformer2w_parameters","text":"calculate_3ph_transformer2w_parameters(case::JuliaPowerCase, jpc_3ph::Utils.JPC_3ph)\n\nCalculate two-winding transformer parameters for positive and negative sequence components.\n\nThis function processes two-winding transformer data from a JuliaPowerCase and converts it to JPC format for both positive and negative sequence components. For most transformers, negative sequence parameters are equal to positive sequence parameters.\n\nArguments\n\ncase::JuliaPowerCase: The power system case data\njpc_3ph::Utils.JPC_3ph: The three-phase JPC object to be populated\n\nSide effects\n\nUpdates jpc_3ph.branchAC_1 (positive sequence) and jpc_3ph.branchAC_2 (negative sequence)\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.calculate_branch_JPC_zero-Tuple{JuliaPowerCase, HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_3ph}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.calculate_branch_JPC_zero","text":"calculate_branch_JPC_zero(case::JuliaPowerCase, jpc_3ph::Utils.JPC_3ph)\n\nCalculate zero sequence branch parameters for lines and transformers.\n\nThis function creates the zero sequence branch matrix and populates it with parameters for lines and transformers. Zero sequence parameters often differ significantly from positive sequence parameters, especially for transformers with different winding connections.\n\nArguments\n\ncase::JuliaPowerCase: The power system case data\njpc_3ph::Utils.JPC_3ph: The three-phase JPC object to be populated\n\nReturns\n\njpc_3ph::Utils.JPC_3ph: The updated JPC_3ph object with zero sequence branch data\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#Other-Functions","page":"Utils API","title":"Other Functions","text":"","category":"section"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.extract_islands-Tuple{JPC}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.extract_islands","text":"extract_islands(jpc::JPC)\n\nExtract electrically isolated islands from a power system case.\n\nThis function identifies separate electrical islands in the power system and creates individual JPC objects for each valid island. It also identifies isolated buses that don't belong to any energized island.\n\nArguments\n\njpc::JPC: Power system case data structure\n\nReturns\n\nVector{JPC}: List of JPC objects, each representing an energized island\nVector{Int}: List of isolated buses (buses not connected to any energized island)\n\nNotes\n\nAn island is considered valid/energized if it contains at least one generator or reference bus\nIslands with only PQ buses and no generation are considered isolated\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.extract_islands_acdc-Tuple{JPC}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.extract_islands_acdc","text":"extract_islands_acdc(jpc::JPC)\n\nExtract electrically isolated islands from a hybrid AC-DC power system case.\n\nThis function identifies separate electrical islands in a hybrid AC-DC power system and creates individual JPC objects for each valid island. It handles the complexity of interconnected AC and DC subsystems through converters.\n\nArguments\n\njpc::JPC: Power system case data structure containing both AC and DC components\n\nReturns\n\nVector{JPC}: List of JPC objects, each representing an energized island\nVector{Int}: List of isolated AC buses (buses not connected to any energized island)\n\nNotes\n\nAn island is considered valid/energized if it contains at least one generator, reference bus, or has a power source in its connected DC subsystem\nIslands with only PQ buses and no generation capability are considered isolated\nThe function checks for potential issues like multiple reference nodes or batteries in constant Vdc mode that might cause power flow calculation errors\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.find_islands-Tuple{JPC}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.find_islands","text":"find_islands(jpc::JPC)\n\nFind electrically isolated islands in an AC power system.\n\nThis function identifies connected components in the power network by analyzing the branch connections between buses. It also identifies isolated PQ buses and islands that contain only PQ buses (no generators or reference buses).\n\nArguments\n\njpc::JPC: Power system case data structure\n\nReturns\n\nVector{Vector{Int}}: List of islands (each containing bus IDs)\nVector{Int}: List of isolated buses (PQ buses with no connections)\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.find_islands_acdc-Tuple{JPC}","page":"Utils API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.find_islands_acdc","text":"find_islands_acdc(jpc::JPC)\n\nFind electrically isolated islands in a hybrid AC-DC power system.\n\nThis function extends the island detection to handle both AC and DC subsystems, including converter connections between them. It identifies connected components across the entire network and classifies islands based on their generation capabilities.\n\nArguments\n\njpc::JPC: Power system case data structure containing both AC and DC components\n\nReturns\n\nVector{Vector{Int}}: List of AC islands (each containing bus IDs)\nVector{Int}: List of isolated AC buses (PQ buses with no viable connections)\n\nNotes\n\nIslands with only PQ buses and no generation capability (either directly or through DC connections) are considered isolated\nIf no DC buses exist, the function falls back to the standard AC island detection\n\n\n\n\n\n","category":"method"},{"location":"api/componentmodel/#API-Reference","page":"ComponentModel API","title":"API Reference","text":"","category":"section"},{"location":"api/componentmodel/#AC-Components","page":"ComponentModel API","title":"AC Components","text":"","category":"section"},{"location":"api/componentmodel/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.Bus","page":"ComponentModel API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.Bus","text":"Bus <: AbstractComponent\n\nStructure representing a bus (node) in power systems.\n\nFields\n\nindex::Int: Unique identifier for the bus\nname::String: Bus name\nvn_kv::Float64: Nominal voltage level in kV\nmax_vm_pu::Float64: Maximum voltage magnitude in per unit\nmin_vm_pu::Float64: Minimum voltage magnitude in per unit\nin_service::Bool: Operating status flag\nbus_id::Int: Bus identifier\narea_id::Int: Area identifier the bus belongs to\nzone_id::Int: Zone identifier the bus belongs to\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.BusDC","page":"ComponentModel API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.BusDC","text":"BusDC <: AbstractComponent\n\nRepresents a DC bus (node) in a power system network.\n\nFields\n\nindex::Int: Unique identifier for the bus\nname::String: Name of the bus\nvn_kv::Float64: Nominal voltage in kilovolts\nmax_vm_pu::Float64: Maximum allowed voltage magnitude in per unit\nmin_vm_pu::Float64: Minimum allowed voltage magnitude in per unit\nin_service::Bool: Operational status (true if in service)\nbus_id::Int: External bus identifier\narea_id::Int: Area identifier the bus belongs to\nzone_id::Int: Zone identifier the bus belongs to\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.ACPVSystem","page":"ComponentModel API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.ACPVSystem","text":"ACPVSystem <: AbstractComponent\n\nStructure representing an AC photovoltaic system, including PV module and inverter parameters.\n\nFields\n\nindex::Int: Unique identifier for the PV system\nname::String: PV system name\nbus::Int: Connected bus number\np_mw::Float64: Active power output (MW)\nq_mvar::Float64: Reactive power output (MVar)\nvm_ac_pu::Float64: AC-side voltage magnitude (per unit)\nvm_dc_pu::Float64: DC-side voltage magnitude (per unit)\nloss_percent::Float64: Loss percentage\nloss_mw::Float64: Power loss (MW)\nmax_p_mw::Float64: Maximum active power limit (MW)\nmin_p_mw::Float64: Minimum active power limit (MW)\nmax_q_mvar::Float64: Maximum reactive power limit (MVar)\nmin_q_mvar::Float64: Minimum reactive power limit (MVar)\nnumpanelseries::Int: Number of panels in series\nnumpanelparallel::Int: Number of panels in parallel\nvmpp::Float64: Maximum power point voltage\nimpp::Float64: Maximum power point current\nvoc::Float64: Open-circuit voltage\nisc::Float64: Short-circuit current\npvanumcells::Int: Number of PV cells\nirradiance::Float64: Irradiance (W/m²)\ntemperature::Float64: Temperature (°C)\nα_isc::Float64: Short-circuit current temperature coefficient\nβ_voc::Float64: Open-circuit voltage temperature coefficient\ncontrol_mode::String: Control mode\ncontrollable::Bool: Controllability flag\nin_service::Bool: Operating status flag\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.ExternalGrid","page":"ComponentModel API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.ExternalGrid","text":"ExternalGrid <: AbstractComponent\n\nStructure representing an external grid, used for modeling equivalent representations of external power systems.\n\nFields\n\nindex::Int: Unique identifier for the external grid\nname::String: External grid name\nbus::Int: Connected bus number\nvm_pu::Float64: Voltage magnitude (per unit)\nva_degree::Float64: Voltage angle (degrees)\nin_service::Bool: Operating status flag\ns_sc_max_mva::Float64: Maximum short-circuit capacity (MVA)\ns_sc_min_mva::Float64: Minimum short-circuit capacity (MVA)\nrx_max::Float64: Maximum R/X ratio\nrx_min::Float64: Minimum R/X ratio\nr0x0_max::Float64: Maximum zero-sequence R/X ratio\nx0x_max::Float64: Maximum ratio of zero-sequence to positive-sequence reactance\ncontrollable::Bool: Controllability flag\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.Generator","page":"ComponentModel API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.Generator","text":"Generator <: AbstractComponent\n\nStructure representing a conventional generator unit, including detailed generator parameters and operational characteristics.\n\nFields\n\nindex::Int: Unique identifier for the generator\nname::String: Generator name\nbus::Int: Connected bus number\np_mw::Float64: Active power output (MW)\nvm_pu::Float64: Voltage magnitude (per unit)\nsn_mva::Float64: Rated capacity (MVA)\nscaling::Float64: Power scaling factor\nmax_p_mw::Float64: Maximum active power limit (MW)\nmin_p_mw::Float64: Minimum active power limit (MW)\nmax_q_mvar::Float64: Maximum reactive power limit (MVar)\nmin_q_mvar::Float64: Minimum reactive power limit (MVar)\nvn_kv::Float64: Rated voltage (kV)\nxdss_pu::Float64: Subtransient direct-axis reactance (per unit)\nrdss_pu::Float64: Subtransient resistance (per unit)\ncos_phi::Float64: Power factor\ncontrollable::Bool: Controllability flag\nin_service::Bool: Operating status flag\ntype::String: Generator type\ngenerator_type::String: Generator technology type\nfuel_type::String: Fuel type\nstartup_time_cold_h::Float64: Cold startup time (hours)\nstartup_time_warm_h::Float64: Warm startup time (hours)\nstartup_time_hot_h::Float64: Hot startup time (hours)\nmin_up_time_h::Float64: Minimum up time (hours)\nmin_down_time_h::Float64: Minimum down time (hours)\nramp_up_rate_mw_per_min::Float64: Ramp-up rate (MW/minute)\nramp_down_rate_mw_per_min::Float64: Ramp-down rate (MW/minute)\nefficiency_percent::Float64: Efficiency percentage\nheat_rate_mmbtu_per_mwh::Float64: Heat rate (MMBtu/MWh)\nco2_emission_rate_kg_per_mwh::Float64: CO2 emission rate (kg/MWh)\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.StaticGenerator","page":"ComponentModel API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.StaticGenerator","text":"StaticGenerator <: AbstractComponent\n\nStructure representing a static generator, used for modeling simplified generator units.\n\nFields\n\nindex::Int: Unique identifier for the generator\nname::String: Generator name\nbus::Int: Connected bus number\np_mw::Float64: Active power output (MW)\nq_mvar::Float64: Reactive power output (MVar)\nscaling::Float64: Power scaling factor\nmax_p_mw::Float64: Maximum active power limit (MW)\nmin_p_mw::Float64: Minimum active power limit (MW)\nmax_q_mvar::Float64: Maximum reactive power limit (MVar)\nmin_q_mvar::Float64: Minimum reactive power limit (MVar)\nk::Float64: Coefficient k (typically used for control equations)\nrx::Float64: Resistance to reactance ratio\nin_service::Bool: Operating status flag\ntype::String: Generator type (WP-wind power, PV-photovoltaic, CHP-combined heat and power, etc.)\ncontrollable::Bool: Controllability flag\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.StaticGeneratorDC","page":"ComponentModel API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.StaticGeneratorDC","text":"StaticGeneratorDC <: AbstractComponent\n\nRepresents a static generator in a DC power flow model.\n\nFields\n\nindex::Int: Unique identifier for the generator\nname::String: Name of the generator\nbus::Int: Bus identifier where the generator is connected\np_mw::Float64: Active power output in MW\nscaling::Float64: Scaling factor for the generator output\nmax_p_mw::Float64: Maximum active power output in MW\nmin_p_mw::Float64: Minimum active power output in MW\nk::Float64: Participation factor for power balancing\nrx::Float64: R/X ratio of the generator\nin_service::Bool: Operational status (true if in service)\ntype::String: Generator type (WP-wind power, PV-photovoltaic, CHP-combined heat and power, etc.)\ncontrollable::Bool: Whether the generator output can be controlled\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.StorageAC","page":"ComponentModel API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.StorageAC","text":"StorageAC <: AbstractComponent\n\nStructure representing an AC storage system.\n\nFields\n\nindex::Int: Unique identifier for the storage system\nname::String: Storage system name\nbus::Int: Connected bus number\npower_capacity_mw::Float64: Power capacity (MW)\nenergy_capacity_mwh::Float64: Energy capacity (MWh)\nsoc_init::Float64: Initial state of charge\nmin_soc::Float64: Minimum state of charge\nmax_soc::Float64: Maximum state of charge\nefficiency::Float64: Charging/discharging efficiency\nin_service::Bool: Operating status flag\ntype::String: Storage type\ncontrollable::Bool: Controllability flag\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.AsymmetricLoad","page":"ComponentModel API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.AsymmetricLoad","text":"AsymmetricLoad <: AbstractComponent\n\nStructure representing an asymmetric load in power systems.\n\nFields\n\nindex::Int: Unique identifier for the load\nname::String: Load name\nbus::Int: Bus number where the load is connected\np_mw::Float64: Active power demand (MW)\nq_mvar::Float64: Reactive power demand (MVAr)\nconst_z_percent::Float64: Percentage of constant impedance load model\nconst_i_percent::Float64: Percentage of constant current load model\nconst_p_percent::Float64: Percentage of constant power load model\nscaling::Float64: Scaling factor for the load\nin_service::Bool: Operating status flag\ntype::String: Load connection type (wye, delta, etc.)\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.Load","page":"ComponentModel API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.Load","text":"Load <: AbstractComponent\n\nStructure representing a symmetric load in power systems.\n\nFields\n\nindex::Int: Unique identifier for the load\nname::String: Load name\nbus::Int: Bus number where the load is connected\np_mw::Float64: Active power demand (MW)\nq_mvar::Float64: Reactive power demand (MVAr)\nconst_z_percent::Float64: Percentage of constant impedance load model\nconst_i_percent::Float64: Percentage of constant current load model\nconst_p_percent::Float64: Percentage of constant power load model\nscaling::Float64: Scaling factor for the load\nin_service::Bool: Operating status flag\ntype::String: Load connection type (wye, delta, etc.)\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.LoadDC","page":"ComponentModel API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.LoadDC","text":"LoadDC <: AbstractComponent\n\nRepresents a symmetric load model in a DC power flow analysis.\n\nFields\n\nindex::Int: Unique identifier for the load\nname::String: Name of the load\nbus::Int: Bus identifier where the load is connected\np_mw::Float64: Active power consumption in MW\nconst_z_percent::Float64: Percentage of load with constant impedance characteristic\nconst_i_percent::Float64: Percentage of load with constant current characteristic\nconst_p_percent::Float64: Percentage of load with constant power characteristic\nscaling::Float64: Scaling factor for the load\nin_service::Bool: Operational status (true if in service)\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.PVArray","page":"ComponentModel API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.PVArray","text":"PVArray <: AbstractComponent\n\nRepresents a photovoltaic array in a power system.\n\nFields\n\nindex::Int: Unique identifier for the PV array\nname::String: Name of the PV array\nbus::Int: Bus identifier where the PV array is connected\nnumpanelseries::Int: Number of panels connected in series\nnumpanelparallel::Int: Number of panel strings connected in parallel\nvmpp::Float64: Voltage at maximum power point in volts\nimpp::Float64: Current at maximum power point in amperes\nvoc::Float64: Open circuit voltage in volts\nisc::Float64: Short circuit current in amperes\npvanumcells::Int: Number of cells in each PV panel\ntemperature::Float64: Operating temperature in degrees Celsius\nirradiance::Float64: Solar irradiance in W/m²\nα_isc::Float64: Temperature coefficient of short circuit current in %/°C\nβ_voc::Float64: Temperature coefficient of open circuit voltage in %/°C\nin_service::Bool: Operational status (true if in service)\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.HighVoltageCircuitBreaker","page":"ComponentModel API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.HighVoltageCircuitBreaker","text":"HighVoltageCircuitBreaker <: AbstractComponent\n\nStructure representing high voltage circuit breakers in power systems.\n\nFields\n\nindex::Int: Unique identifier for the circuit breaker\nname::String: Circuit breaker name\nbus_from::Int: Starting bus number\nbus_to::Int: Ending bus number\nelement_type::String: Connected element type (l-line, t-transformer, b-bus)\nelement_id::Int: Connected element identifier\nclosed::Bool: Circuit breaker status (closed/open)\ntype::String: Circuit breaker type (CB-circuit breaker, LS-load switch, DS-disconnector switch)\nz_ohm::Float64: Circuit breaker impedance (Ω)\nin_service::Bool: Operating status flag\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.Line","page":"ComponentModel API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.Line","text":"Line <: AbstractComponent\n\nStructure representing AC transmission or distribution lines in power systems.\n\nFields\n\nindex::Int: Unique identifier for the line\nname::String: Line name\nfrom_bus::Int: Starting bus number\nto_bus::Int: Ending bus number\nlength_km::Float64: Line length (km)\nr_ohm_per_km::Float64: Positive sequence resistance per kilometer (Ω/km)\nx_ohm_per_km::Float64: Positive sequence reactance per kilometer (Ω/km)\nc_nf_per_km::Float64: Positive sequence capacitance per kilometer (nF/km)\nr0_ohm_per_km::Float64: Zero sequence resistance per kilometer (Ω/km)\nx0_ohm_per_km::Float64: Zero sequence reactance per kilometer (Ω/km)\nc0_nf_per_km::Float64: Zero sequence capacitance per kilometer (nF/km)\ng_us_per_km::Float64: Conductance per kilometer (μS/km)\nmax_i_ka::Float64: Maximum allowable current (kA)\ntype::String: Line type (cs-cable, ol-overhead line)\nmax_loading_percent::Float64: Maximum loading percentage\nparallel::Int: Number of parallel lines\ndf::Float64: Distribution factor\nin_service::Bool: Operating status flag\n\nReliability Parameters\n\nmtbf_hours::Float64: Mean time between failures (hours)\nmttr_hours::Float64: Mean time to repair (hours)\nsw_hours::Float64: Switching operation time (hours)\nrp_hours::Float64: Repair preparation time (hours)\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.LineDC","page":"ComponentModel API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.LineDC","text":"LineDC <: AbstractComponent\n\nRepresents a DC transmission line in a power system.\n\nFields\n\nindex::Int: Unique identifier for the line\nname::String: Name of the line\nfrom_bus::Int: Bus identifier where the line starts\nto_bus::Int: Bus identifier where the line ends\nlength_km::Float64: Length of the line in kilometers\nr_ohm_per_km::Float64: Resistance per kilometer in ohms\nx_ohm_per_km::Float64: Reactance per kilometer in ohms\ng_us_per_km::Float64: Conductance per kilometer in microsiemens\nmax_i_ka::Float64: Maximum current capacity in kiloamperes\ntype::String: Type of the line\nmax_loading_percent::Float64: Maximum loading percentage allowed\nparallel::Int: Number of parallel lines\ndf::Float64: Derating factor\nin_service::Bool: Operational status (true if in service)\nmtbf_hours::Float64: Mean time between failures in hours\nmttr_hours::Float64: Mean time to repair in hours\nsw_hours::Float64: Switching time in hours\nrp_hours::Float64: Replacement time in hours\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.Switch","page":"ComponentModel API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.Switch","text":"Switch <: AbstractComponent\n\nStructure representing switching devices in power systems.\n\nFields\n\nindex::Int: Unique identifier for the switch\nname::String: Switch name\nbus_from::Int: Starting bus number\nbus_to::Int: Ending bus number\nelement_type::String: Connected element type (l-line, t-transformer, b-bus)\nelement_id::Int: Connected element identifier\nclosed::Bool: Switch status (closed/open)\ntype::String: Switch type (CB-circuit breaker, LS-load switch, DS-disconnector switch)\nz_ohm::Float64: Switch impedance (Ω)\nin_service::Bool: Operating status flag\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.Transformer2W","page":"ComponentModel API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.Transformer2W","text":"Transformer2W <: AbstractComponent\n\nRepresents a two-winding transformer in power systems.\n\nFields\n\nindex::Int: Unique identifier for the transformer\nname::String: Transformer name\nstd_type::String: Standard type\nhv_bus::Int: High voltage bus number\nlv_bus::Int: Low voltage bus number\nsn_mva::Float64: Rated power (MVA)\nvn_hv_kv::Float64: Rated voltage at HV side (kV)\nvn_lv_kv::Float64: Rated voltage at LV side (kV)\nvk_percent::Float64: Short-circuit impedance in percent\nvkr_percent::Float64: Short-circuit resistance in percent\npfe_kw::Float64: Iron losses (kW)\ni0_percent::Float64: No-load current in percent\nshift_degree::Float64: Phase shift angle in degrees\n\nTap changer parameters\n\ntap_side::String: Tap changer side (hv/lv)\ntap_neutral::Int: Neutral tap position\ntap_min::Int: Minimum tap position\ntap_max::Int: Maximum tap position\ntap_step_percent::Float64: Tap step size in percent\ntap_step_degree::Float64: Tap step angle in degrees\ntap_pos::Int: Current tap position\ntap_phase_shifter::Bool: Whether it's a phase shifter\n\nOther parameters\n\nparallel::Int: Number of parallel transformers\nmax_loading_percent::Float64: Maximum loading in percent\ndf::Float64: Distribution factor\nin_service::Bool: Operating status flag\noltc::Bool: Whether it has on-load tap changer\npower_station_unit::Bool: Whether it's a power station transformer\n\nTechnical parameters\n\nvector_group::String: Vector group\nhv_connection::String: HV side connection type (Y/D)\nlv_connection::String: LV side connection type (Y/D)\nthermal_capacity_mw::Float64: Thermal capacity (MW)\ncooling_type::String: Cooling method\noil_volume_liters::Float64: Oil volume (liters)\nwinding_material::String: Winding material\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.Transformer2Wetap","page":"ComponentModel API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.Transformer2Wetap","text":"Transformer2Wetap <: AbstractComponent\n\nRepresents a two-winding transformer with ETAP parameters.\n\nFields\n\nindex::Int: Unique identifier for the transformer\nname::String: Transformer name\nstd_type::String: Standard type\nhv_bus::Int: High voltage bus number\nlv_bus::Int: Low voltage bus number\nsn_mva::Float64: Rated power (MVA)\nvn_hv_kv::Float64: Rated voltage at HV side (kV)\nvn_lv_kv::Float64: Rated voltage at LV side (kV)\nz_percent::Float64: Impedance in percent\nx_r::Float64: X/R ratio\nz0_percent::Float64: Zero sequence impedance in percent\nx0_r0::Float64: Zero sequence X/R ratio\n\nTap changer parameters\n\ntap_neutral::Int: Neutral tap position\nprim_tap::Float64: Primary side tap\nprim_tap_min::Int: Primary side minimum tap position\nprim_tap_max::Int: Primary side maximum tap position\nsec_tap::Float64: Secondary side tap\nsec_tap_min::Int: Secondary side minimum tap position\nsec_tap_max::Int: Secondary side maximum tap position\nvectororwinding::String: Vector or winding type\nphaseshifthl::Float64: Phase shift angle between HV and LV sides\nphaseshiftps: Phase shifter angle\n\nOther parameters\n\nparallel::Int: Number of parallel transformers\nmax_loading_percent::Float64: Maximum loading in percent\ndf::Float64: Distribution factor\nin_service::Bool: Operating status flag\noltc::Bool: Whether it has on-load tap changer\npower_station_unit::Bool: Whether it's a power station transformer\nvector_group::String: Vector group\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.Transformer3W","page":"ComponentModel API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.Transformer3W","text":"Transformer3W <: AbstractComponent\n\nRepresents a three-winding transformer in power systems.\n\nFields\n\nindex::Int: Unique identifier for the transformer\nname::String: Transformer name\nstd_type::String: Standard type\nhv_bus::Int: High voltage bus number\nmv_bus::Int: Medium voltage bus number\nlv_bus::Int: Low voltage bus number\nsn_hv_mva::Float64: HV side rated power (MVA)\nsn_mv_mva::Float64: MV side rated power (MVA)\nsn_lv_mva::Float64: LV side rated power (MVA)\nvn_hv_kv::Float64: Rated voltage at HV side (kV)\nvn_mv_kv::Float64: Rated voltage at MV side (kV)\nvn_lv_kv::Float64: Rated voltage at LV side (kV)\nvk_hv_percent::Float64: HV side short-circuit impedance in percent\nvk_mv_percent::Float64: MV side short-circuit impedance in percent\nvk_lv_percent::Float64: LV side short-circuit impedance in percent\nvkr_hv_percent::Float64: HV side short-circuit resistance in percent\nvkr_mv_percent::Float64: MV side short-circuit resistance in percent\nvkr_lv_percent::Float64: LV side short-circuit resistance in percent\npfe_kw::Float64: Iron losses (kW)\ni0_percent::Float64: No-load current in percent\nshift_mv_degree::Float64: MV side phase shift angle in degrees\nshift_lv_degree::Float64: LV side phase shift angle in degrees\n\nTap changer parameters\n\ntap_side::String: Tap changer side (hv/mv/lv)\ntap_neutral::Int: Neutral tap position\ntap_min::Int: Minimum tap position\ntap_max::Int: Maximum tap position\ntap_step_percent::Float64: Tap step size in percent\ntap_step_degree::Float64: Tap step angle in degrees\ntap_at_star_point::Bool: Whether tap changer is at star point\ntap_pos::Int: Current tap position\n\nOther parameters\n\nin_service::Bool: Operating status flag\n\nTechnical parameters\n\nvector_group_hv_mv::String: HV-MV vector group\nvector_group_hv_lv::String: HV-LV vector group\nvector_group_mv_lv::String: MV-LV vector group\nhv_connection::String: HV side connection type (Y/D)\nmv_connection::String: MV side connection type (Y/D)\nlv_connection::String: LV side connection type (Y/D)\nthermal_capacity_mw::Float64: Thermal capacity (MW)\ncooling_type::String: Cooling method\noil_volume_liters::Float64: Oil volume (liters)\nwinding_material::String: Winding material\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel/#DC-Components","page":"ComponentModel API","title":"DC Components","text":"","category":"section"},{"location":"api/componentmodel/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.MobileStorage","page":"ComponentModel API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.MobileStorage","text":"MobileStorage <: AbstractComponent\n\nRepresents a mobile energy storage system that can be relocated within a power network.\n\nFields\n\nindex::Int: Unique identifier for the mobile storage system\nname::String: Name of the mobile storage system\ntype::String: Type of mobile storage (container, trailer, truck, ship)\ncapacity_mwh::Float64: Energy storage capacity in MWh\npower_mw::Float64: Maximum power capacity in MW\nsoc_percent::Float64: Current state of charge as a percentage (0-100)\ncharge_efficiency_percent::Float64: Charging efficiency as a percentage (0-100)\ndischarge_efficiency_percent::Float64: Discharging efficiency as a percentage (0-100)\nowner::String: Owner or operator of the mobile storage system\navailability::Float64: Availability factor (0-1)\ncurrent_location::String: Current physical location of the mobile storage\nstatus::String: Current operational status (available, in_transit, connected, maintenance)\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.Storage","page":"ComponentModel API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.Storage","text":"Storage <: AbstractComponent\n\nRepresents a stationary energy storage system in a power network.\n\nFields\n\nindex::Int: Unique identifier for the storage system\nname::String: Name of the storage system\nbus::Int: Bus identifier where the storage system is connected\npower_capacity_mw::Float64: Maximum power capacity in MW\nenergy_capacity_mwh::Float64: Energy storage capacity in MWh\nsoc_init::Float64: Initial state of charge (0-1)\nmin_soc::Float64: Minimum allowed state of charge (0-1)\nmax_soc::Float64: Maximum allowed state of charge (0-1)\nefficiency::Float64: Round-trip efficiency of the storage system (0-1)\nin_service::Bool: Operational status (true if in service)\ntype::String: Type of storage technology (e.g., \"battery\", \"pumped_hydro\")\ncontrollable::Bool: Whether the storage system can be controlled externally\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.Storageetap","page":"ComponentModel API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.Storageetap","text":"Storageetap <: AbstractComponent\n\nRepresents a detailed electrochemical energy storage model with electrical and thermal parameters.\n\nFields\n\nindex::Int: Unique identifier for the storage system\nname::String: Name of the storage system\nbus::Int: Bus identifier where the storage system is connected\nra::Float64: Internal resistance in ohms\ncell::Float64: Number of cells in series per string\nstr::Float64: Number of strings in parallel\npackage::Float64: Number of packages in parallel\nvoc::Float64: Open circuit voltage in volts\nin_service::Bool: Operational status (true if in service)\ntype::String: Type of storage technology\ncontrollable::Bool: Whether the storage system can be controlled externally\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel/#Hybrid-Components","page":"ComponentModel API","title":"Hybrid Components","text":"","category":"section"},{"location":"api/componentmodel/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.Converter","page":"ComponentModel API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.Converter","text":"Converter Structure\n\nRepresents a power converter that connects AC and DC systems, with control capabilities\nand operational parameters.\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.Charger","page":"ComponentModel API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.Charger","text":"Charger Structure\n\nRepresents an individual charging unit within a charging station, with specific power\ncapabilities and connector types.\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.ChargingStation","page":"ComponentModel API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.ChargingStation","text":"ChargingStation Structure\n\nRepresents an electric vehicle charging station with multiple chargers and connection\nto the power system at a specific bus.\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.EVAggregator","page":"ComponentModel API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.EVAggregator","text":"EVAggregator Structure\n\nRepresents an entity that aggregates multiple electric vehicles to provide\ngrid services and manage charging/discharging operations collectively.\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.V2GService","page":"ComponentModel API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.V2GService","text":"V2GService Structure\n\nRepresents a vehicle-to-grid service provided by an aggregator, including\nservice type, time period, capacity, and pricing information.\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.Microgrid","page":"ComponentModel API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.Microgrid","text":"Microgrid Structure\n\nRepresents a microgrid with generation, storage, and load resources that can\noperate connected to or isolated from the main grid.\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.FlexLoad","page":"ComponentModel API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.FlexLoad","text":"FlexLoad Structure\n\nRepresents a flexible load that can adjust its consumption pattern\nin response to grid signals or price incentives.\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.VirtualPowerPlant","page":"ComponentModel API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.VirtualPowerPlant","text":"VirtualPowerPlant Structure\n\nRepresents a virtual power plant that aggregates distributed energy resources\nto provide grid services and operate as a single controllable entity.\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel/#Carbon-Components","page":"ComponentModel API","title":"Carbon Components","text":"","category":"section"},{"location":"api/componentmodel/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.CarbonScenario","page":"ComponentModel API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.CarbonScenario","text":"CarbonScenario <: AbstractComponent\n\nRepresents a carbon emission scenario for power system analysis.\n\nFields\n\nindex::Int: Unique identifier for the scenario\nname::String: Scenario name\ndescription::String: Detailed description of the scenario\nyear::Int: Target year for the scenario\ngrid_carbon_intensity_kgCO2e_per_MWh::Float64: Average grid carbon intensity in kg CO2 equivalent per MWh\nrenewable_penetration_percent::Float64: Percentage of renewable energy penetration\nev_adoption_percent::Float64: Percentage of electric vehicle adoption\nstorage_adoption_percent::Float64: Percentage of energy storage adoption\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.CarbonTimeSeries","page":"ComponentModel API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.CarbonTimeSeries","text":"CarbonTimeSeries <: AbstractComponent\n\nRepresents a time series of carbon emission data in power systems.\n\nFields\n\nindex::Int: Unique identifier for the time series record\ntimestamp::DateTime: Time point of the carbon emission data\ngrid_carbon_intensity_kgCO2e_per_MWh::Float64: Grid carbon intensity in kg CO2 equivalent per MWh\nrenewable_generation_carbon_intensity_kgCO2e_per_MWh::Float64: Carbon intensity of renewable generation in kg CO2 equivalent per MWh\nstorage_carbon_intensity_kgCO2e_per_MWh::Float64: Carbon intensity of energy storage in kg CO2 equivalent per MWh\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.EquipmentCarbon","page":"ComponentModel API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.ComponentModel.EquipmentCarbon","text":"EquipmentCarbon <: AbstractComponent\n\nRepresents carbon emission data for power system equipment.\n\nFields\n\nindex::Int: Unique identifier for the equipment carbon record\nelement_type::String: Type of equipment (e.g., \"transformer\", \"line\", \"generator\")\nelement_id::Int: Identifier of the specific equipment\ncarbon_embodied_kgCO2e::Float64: Embodied carbon in the equipment in kg CO2 equivalent\ncarbon_operational_kgCO2e_per_year::Float64: Annual operational carbon emissions in kg CO2 equivalent per year\nlifetime_years::Int: Expected lifetime of the equipment in years\nmanufacturing_date::Date: Date when the equipment was manufactured\ninstallation_date::Date: Date when the equipment was installed\nrecycling_rate_percent::Float64: Percentage of materials that can be recycled at end of life\n\n\n\n\n\n","category":"type"},{"location":"modules/powerflow/#PowerFlow-Module","page":"PowerFlow","title":"PowerFlow Module","text":"","category":"section"},{"location":"modules/powerflow/#Overview","page":"PowerFlow","title":"Overview","text":"","category":"section"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"The PowerFlow module provides comprehensive power flow analysis capabilities for electrical power systems. It includes implementations of various power flow algorithms including AC Newton-Raphson, DC power flow, and hybrid power flow for integrated AC/DC systems. The module supports both balanced and unbalanced power flow analysis with various features for handling different system components and control modes.","category":"page"},{"location":"modules/powerflow/#Flow-Chart","page":"PowerFlow","title":"Flow Chart","text":"","category":"section"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"(Image: PowerFlow flow chart)","category":"page"},{"location":"modules/powerflow/#Core-Features","page":"PowerFlow","title":"Core Features","text":"","category":"section"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"AC power flow using Newton-Raphson method\nDC power flow analysis\nHybrid power flow for integrated AC/DC systems\nUnbalanced power flow analysis\nGPU-accelerated computations\nSupport for ZIP load models\nPV system integration\nComprehensive results processing and reporting","category":"page"},{"location":"modules/powerflow/#Main-Functions","page":"PowerFlow","title":"Main Functions","text":"","category":"section"},{"location":"modules/powerflow/#Power-Flow-Execution","page":"PowerFlow","title":"Power Flow Execution","text":"","category":"section"},{"location":"modules/powerflow/#runpf(case,-opt)","page":"PowerFlow","title":"runpf(case, opt)","text":"","category":"section"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Main function to execute AC power flow calculations.","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Arguments:","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"case: Power system case data\nopt: Options dictionary containing power flow parameters","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Returns:","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Results structure containing power flow solution","category":"page"},{"location":"modules/powerflow/#rundcpf(case,-opt)","page":"PowerFlow","title":"rundcpf(case, opt)","text":"","category":"section"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Executes DC power flow analysis.","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Arguments:","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"case: Power system case data\nopt: Options dictionary containing DC power flow parameters","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Returns:","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Results structure containing DC power flow solution","category":"page"},{"location":"modules/powerflow/#runhpf(jpc,-opt)","page":"PowerFlow","title":"runhpf(jpc, opt)","text":"","category":"section"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Runs hybrid power flow calculation for integrated AC/DC systems.","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Arguments:","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"jpc: MATPOWER-style power flow case structure\nopt: Options dictionary containing hybrid power flow parameters","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Returns:","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Results structure containing hybrid power flow solution","category":"page"},{"location":"modules/powerflow/#runupf(case,-jpc_3ph,-gs_eg,-bs_eg,-opt)","page":"PowerFlow","title":"runupf(case, jpc_3ph, gs_eg, bs_eg, opt)","text":"","category":"section"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Executes unbalanced power flow analysis on unsymmetrical load nodes.","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Arguments:","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"case: Power system case data\njpc_3ph: Three-phase power flow case structure\ngs_eg, bs_eg: Shunt conductance and susceptance\nopt: Options dictionary","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Returns:","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Results structure containing unbalanced power flow solution","category":"page"},{"location":"modules/powerflow/#Solution-Algorithms","page":"PowerFlow","title":"Solution Algorithms","text":"","category":"section"},{"location":"modules/powerflow/#newtonpf(baseMVA,-bus,-gen,-branch,-Ybus,-Yf,-Yt,-V0,-ref,-pv,-pq,-mpopt)","page":"PowerFlow","title":"newtonpf(baseMVA, bus, gen, branch, Ybus, Yf, Yt, V0, ref, pv, pq, mpopt)","text":"","category":"section"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Solves power flow using Newton-Raphson method.","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Arguments:","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"baseMVA: Base MVA\nbus, gen, branch: System component data\nYbus, Yf, Yt: Admittance matrices\nV0: Initial voltage vector\nref, pv, pq: Bus type indices\nmpopt: MATPOWER options structure","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Returns:","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Voltage solution and convergence information","category":"page"},{"location":"modules/powerflow/#newtondcpf(baseMVA,-bus,-branch,-Bbus,-Bf,-Pbusinj,-Pfinj,-Va0,-ref,-pv,-pq,-mpopt)","page":"PowerFlow","title":"newtondcpf(baseMVA, bus, branch, Bbus, Bf, Pbusinj, Pfinj, Va0, ref, pv, pq, mpopt)","text":"","category":"section"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Solves DC power flow using Newton method.","category":"page"},{"location":"modules/powerflow/#adaptive_damped_newton(baseMVA,-bus,-gen,-branch,-Ybus,-Yf,-Yt,-V0,-ref,-pv,-pq,-mpopt)","page":"PowerFlow","title":"adaptive_damped_newton(baseMVA, bus, gen, branch, Ybus, Yf, Yt, V0, ref, pv, pq, mpopt)","text":"","category":"section"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Implements adaptive damped Newton method for improved convergence.","category":"page"},{"location":"modules/powerflow/#currentinjectionpf(baseMVA,-bus,-gen,-branch,-Ybus,-Yf,-Yt,-V0,-ref,-pv,-pq,-mpopt)","page":"PowerFlow","title":"currentinjectionpf(baseMVA, bus, gen, branch, Ybus, Yf, Yt, V0, ref, pv, pq, mpopt)","text":"","category":"section"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Solves power flow using current injection method.","category":"page"},{"location":"modules/powerflow/#System-Construction","page":"PowerFlow","title":"System Construction","text":"","category":"section"},{"location":"modules/powerflow/#makeYbus(baseMVA,-bus,-branch)","page":"PowerFlow","title":"makeYbus(baseMVA, bus, branch)","text":"","category":"section"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Builds the bus admittance matrix (Ybus) and branch admittance matrices (Yf, Yt).","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Arguments:","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"baseMVA: Base MVA\nbus: Bus data matrix\nbranch: Branch data matrix","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Returns:","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Ybus: Bus admittance matrix\nYf: From-bus branch admittance matrix\nYt: To-bus branch admittance matrix","category":"page"},{"location":"modules/powerflow/#makeBdc(baseMVA,-bus,-branch)","page":"PowerFlow","title":"makeBdc(baseMVA, bus, branch)","text":"","category":"section"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Builds the DC power flow matrices.","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Arguments:","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"baseMVA: Base MVA\nbus: Bus data matrix\nbranch: Branch data matrix","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Returns:","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Bbus: Nodal susceptance matrix\nBf: Branch susceptance matrix for line flows\nOther DC model matrices","category":"page"},{"location":"modules/powerflow/#makeSbus(baseMVA,-bus,-gen,-Vm,-load,-pvarray;-dcfalse,-Sgnothing,-return_derivativefalse)","page":"PowerFlow","title":"makeSbus(baseMVA, bus, gen, Vm, load, pvarray; dc=false, Sg=nothing, return_derivative=false)","text":"","category":"section"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Builds the vector of complex bus power injections.","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Arguments:","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"baseMVA: Base MVA\nbus: Bus data matrix\ngen: Generator data matrix\nVm: Voltage magnitude vector\nload: Load data matrix\npvarray: PV array data\nAdditional optional parameters","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Returns:","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Vector of complex bus power injections","category":"page"},{"location":"modules/powerflow/#calculate_line_parameter(net,-jpc,-sequence,-opt)","page":"PowerFlow","title":"calculate_line_parameter(net, jpc, sequence, opt)","text":"","category":"section"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Calculates line parameters for the branch matrix based on the specified sequence.","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Arguments:","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"net: Network data structure\njpc: MATPOWER-style power flow case structure\nsequence: Sequence type (1 for positive, 2 for negative, 0 for zero)\nopt: Options dictionary","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Returns:","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Updated jpc structure with branch parameters","category":"page"},{"location":"modules/powerflow/#Bus-and-Generator-Construction","page":"PowerFlow","title":"Bus and Generator Construction","text":"","category":"section"},{"location":"modules/powerflow/#calculate_bus(net,-jpc,-sequence,-slack_bus,-opt)","page":"PowerFlow","title":"calculate_bus(net, jpc, sequence, slack_bus, opt)","text":"","category":"section"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Builds the bus matrix for power flow calculations.","category":"page"},{"location":"modules/powerflow/#build_gen(net,-jpc)","page":"PowerFlow","title":"build_gen(net, jpc)","text":"","category":"section"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Builds the generator matrix for power flow calculations.","category":"page"},{"location":"modules/powerflow/#Bus-Type-Identification","page":"PowerFlow","title":"Bus Type Identification","text":"","category":"section"},{"location":"modules/powerflow/#bustypes(bus)","page":"PowerFlow","title":"bustypes(bus)","text":"","category":"section"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Identifies bus types (reference, PV, PQ) for AC power flow.","category":"page"},{"location":"modules/powerflow/#dcbustypes(bus)","page":"PowerFlow","title":"dcbustypes(bus)","text":"","category":"section"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Identifies bus types for DC power flow.","category":"page"},{"location":"modules/powerflow/#Jacobian-Calculation","page":"PowerFlow","title":"Jacobian Calculation","text":"","category":"section"},{"location":"modules/powerflow/#dSbus_dV(Ybus,-V,-vcart)","page":"PowerFlow","title":"dSbus_dV(Ybus, V, vcart)","text":"","category":"section"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Computes partial derivatives of power injection w.r.t. voltage.","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Arguments:","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Ybus: Bus admittance matrix\nV: Complex bus voltage vector\nvcart: Boolean flag for cartesian coordinates","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Returns:","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Partial derivatives of power injection","category":"page"},{"location":"modules/powerflow/#Solution-Processing","page":"PowerFlow","title":"Solution Processing","text":"","category":"section"},{"location":"modules/powerflow/#pfsoln(baseMVA,-bus,-gen,-branch,-Ybus,-Yf,-Yt,-V,-ref,-pv,-pq,-opt)","page":"PowerFlow","title":"pfsoln(baseMVA, bus, gen, branch, Ybus, Yf, Yt, V, ref, pv, pq, opt)","text":"","category":"section"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Updates power flow solution with computed voltage values and calculates generator outputs and branch flows.","category":"page"},{"location":"modules/powerflow/#dcpfsoln(baseMVA,-bus0,-gen0,-branch0,-Bbus,-Bf,-Pbusinj,-Pfinj,-Va,-success,-et,-opt)","page":"PowerFlow","title":"dcpfsoln(baseMVA, bus0, gen0, branch0, Bbus, Bf, Pbusinj, Pfinj, Va, success, et, opt)","text":"","category":"section"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Updates DC power flow solution.","category":"page"},{"location":"modules/powerflow/#merge_results(results)","page":"PowerFlow","title":"merge_results(results)","text":"","category":"section"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Merges power flow results from multiple calculations.","category":"page"},{"location":"modules/powerflow/#process_result(results,-case,-opt)","page":"PowerFlow","title":"process_result(results, case, opt)","text":"","category":"section"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Processes power flow calculation results and generates summary.","category":"page"},{"location":"modules/powerflow/#process_pv_acsystem(case,-results,-opt)","page":"PowerFlow","title":"process_pv_acsystem(case, results, opt)","text":"","category":"section"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Processes PV AC systems and integrates them into the power flow solution.","category":"page"},{"location":"modules/powerflow/#Utility-Functions","page":"PowerFlow","title":"Utility Functions","text":"","category":"section"},{"location":"modules/powerflow/#julinsolve(A,-b,-solver)","page":"PowerFlow","title":"julinsolve(A, b, solver)","text":"","category":"section"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Solves linear system Ax = b using specified solver.","category":"page"},{"location":"modules/powerflow/#total_load(bus,-load)","page":"PowerFlow","title":"total_load(bus, load)","text":"","category":"section"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Calculates total load in the system.","category":"page"},{"location":"modules/powerflow/#eliminate_element(mpc,-element_type,-element_id)","page":"PowerFlow","title":"eliminate_element(mpc, element_type, element_id)","text":"","category":"section"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Eliminates a specific element from the power system model.","category":"page"},{"location":"modules/powerflow/#Results-Reporting","page":"PowerFlow","title":"Results Reporting","text":"","category":"section"},{"location":"modules/powerflow/#pf_summary","page":"PowerFlow","title":"pf_summary","text":"","category":"section"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Generates comprehensive power flow summary reports including:","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"System summary\nBus data\nBranch data\nGenerator data\nVoltage violations\nBranch violations\nSystem losses","category":"page"},{"location":"modules/powerflow/#compare_voltage_results(results,-case,-reference_file;-tolerance_mag1e-4,-tolerance_ang1e-3)","page":"PowerFlow","title":"compare_voltage_results(results, case, reference_file; tolerance_mag=1e-4, tolerance_ang=1e-3)","text":"","category":"section"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Compares power flow calculation results with reference values from external tools like ETAP.","category":"page"},{"location":"modules/powerflow/#GPU-Support","page":"PowerFlow","title":"GPU Support","text":"","category":"section"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"The module includes GPU-accelerated versions of key functions for improved performance on compatible hardware:","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"newtonpf_gpu\nmakeSbus_gpu\nmakeSdzip_gpu","category":"page"},{"location":"modules/powerflow/#Settings-and-Options","page":"PowerFlow","title":"Settings and Options","text":"","category":"section"},{"location":"modules/powerflow/#settings()","page":"PowerFlow","title":"settings()","text":"","category":"section"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Defines default settings for power flow calculations including:","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Convergence tolerance\nMaximum iterations\nAlgorithm selection\nOutput verbosity\nEnforcement options\nInitialization methods","category":"page"},{"location":"modules/powerflow/#Usage-Example","page":"PowerFlow","title":"Usage Example","text":"","category":"section"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"using HyDistFlow.PowerFlow\n\n# Load case data\ncase = case3()\n\n# Set options\nopt = PowerFlow.settings()\nopt[:pf_alg] = :NR  # Newton-Raphson algorithm\nopt[:verbose] = 1\n\n# Run power flow\nresults = PowerFlow.runpf(case, opt)\n\n# Process results\nPowerFlow.process_result(results, case, opt)","category":"page"},{"location":"modules/powerflow/#Advanced-Features","page":"PowerFlow","title":"Advanced Features","text":"","category":"section"},{"location":"modules/powerflow/#Hybrid-Power-Flow","page":"PowerFlow","title":"Hybrid Power Flow","text":"","category":"section"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"The module supports hybrid power flow for integrated AC/DC systems with various converter control modes:","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Vθ control\nPQ control\nPV control\nVdc-Q control\nVdc-Vac control\nDroop control","category":"page"},{"location":"modules/powerflow/#Unbalanced-Power-Flow","page":"PowerFlow","title":"Unbalanced Power Flow","text":"","category":"section"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Unbalanced power flow analysis is supported for unsymmetrical load nodes:","category":"page"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"Identifies unbalanced nodes in the system\nFinds interface branches between balanced and unbalanced nodes\nSolves the unbalanced power flow","category":"page"},{"location":"modules/powerflow/#ZIP-Load-Models","page":"PowerFlow","title":"ZIP Load Models","text":"","category":"section"},{"location":"modules/powerflow/","page":"PowerFlow","title":"PowerFlow","text":"The module supports ZIP (constant impedance, constant current, constant power) load models through the makeSdzip function.","category":"page"},{"location":"modules/overview/#HyDistFlow-Framework-Overview","page":"Overview","title":"HyDistFlow Framework Overview","text":"","category":"section"},{"location":"modules/overview/","page":"Overview","title":"Overview","text":"HyDistFlow is a comprehensive power system analysis framework developed in Julia, focusing on modeling, simulation, and optimization of modern power systems. The framework supports traditional AC systems, DC systems, and hybrid AC/DC systems analysis, providing rich tools to address modern power system challenges including renewable energy integration, carbon emission assessment, and time-series analysis.","category":"page"},{"location":"modules/overview/#Framework-Structure","page":"Overview","title":"Framework Structure","text":"","category":"section"},{"location":"modules/overview/","page":"Overview","title":"Overview","text":"The HyDistFlow framework consists of four core modules, each focusing on different aspects of power system analysis:","category":"page"},{"location":"modules/overview/","page":"Overview","title":"Overview","text":"ComponentModel - Power system component modeling\nUtils - Utility tools and helper functions\nPowerFlow - Power flow calculation algorithms\nTimeDomainPowerFlow - Time-series power flow analysis","category":"page"},{"location":"modules/overview/","page":"Overview","title":"Overview","text":"These modules work together to provide a complete solution from basic component modeling to advanced time-series analysis.","category":"page"},{"location":"modules/overview/#Software-Framework-Diagram","page":"Overview","title":"Software Framework Diagram","text":"","category":"section"},{"location":"modules/overview/","page":"Overview","title":"Overview","text":"(Image: Software framework diagram)","category":"page"},{"location":"modules/overview/#Key-Features","page":"Overview","title":"Key Features","text":"","category":"section"},{"location":"modules/overview/","page":"Overview","title":"Overview","text":"Comprehensive Component Modeling - Support for all major power system components in AC, DC, and hybrid systems\nMultiple Power Flow Algorithms - Including Newton-Raphson, DC power flow, and hybrid power flow calculations\nTime-Series Analysis - Support for dynamic dispatch and long-term system behavior analysis\nRenewable Energy Integration - Specialized models for PV systems and energy storage systems\nCarbon Emission Assessment - Built-in carbon emission models for environmental impact analysis\nHigh-Performance Computing - GPU acceleration for large-scale system analysis","category":"page"},{"location":"modules/overview/#Module-Details","page":"Overview","title":"Module Details","text":"","category":"section"},{"location":"modules/overview/#ComponentModel-Module","page":"Overview","title":"ComponentModel Module","text":"","category":"section"},{"location":"modules/overview/","page":"Overview","title":"Overview","text":"The ComponentModel module provides a comprehensive framework for modeling and simulating power systems, including AC, DC, and hybrid AC/DC components, as well as carbon emission models.","category":"page"},{"location":"modules/overview/","page":"Overview","title":"Overview","text":"Key Features:","category":"page"},{"location":"modules/overview/","page":"Overview","title":"Overview","text":"AC component modeling (Bus, Line, Transformer, Generator, Load)\nDC component modeling (DCBus, DCLine, DCGenerator, DCLoad, Storage)\nConverter modeling (Converter)\nHybrid AC/DC system modeling\nCarbon emission models","category":"page"},{"location":"modules/overview/","page":"Overview","title":"Overview","text":"ComponentModel supports the creation of various power system models from simple single-bus systems to complex hybrid AC/DC grids. It provides an object-oriented API that allows users to intuitively build and manipulate power system models.","category":"page"},{"location":"modules/overview/#Utils-Module","page":"Overview","title":"Utils Module","text":"","category":"section"},{"location":"modules/overview/","page":"Overview","title":"Overview","text":"The Utils module provides utility functions for power system analysis, including data conversion, network topology analysis, and various helper functions for working with power system models.","category":"page"},{"location":"modules/overview/","page":"Overview","title":"Overview","text":"Key Features:","category":"page"},{"location":"modules/overview/","page":"Overview","title":"Overview","text":"Data conversion functions (external/internal indexing conversion)\nNetwork topology analysis (island detection, node mapping)\nData extraction and format conversion\nETAP data import\nIndexing constants and data structures","category":"page"},{"location":"modules/overview/","page":"Overview","title":"Overview","text":"The Utils module serves as the infrastructure of the framework, providing core functionality for handling power system data and models, simplifying the development and use of other modules.","category":"page"},{"location":"modules/overview/#PowerFlow-Module","page":"Overview","title":"PowerFlow Module","text":"","category":"section"},{"location":"modules/overview/","page":"Overview","title":"Overview","text":"The PowerFlow module provides comprehensive power flow analysis capabilities for electrical power systems. It includes implementations of various power flow algorithms including AC Newton-Raphson, DC power flow, and hybrid power flow for integrated AC/DC systems.","category":"page"},{"location":"modules/overview/","page":"Overview","title":"Overview","text":"Key Features:","category":"page"},{"location":"modules/overview/","page":"Overview","title":"Overview","text":"AC Newton-Raphson power flow calculation\nDC power flow analysis\nHybrid AC/DC power flow calculation\nUnbalanced power flow analysis\nGPU-accelerated computations\nZIP load model support\nResults processing and reporting","category":"page"},{"location":"modules/overview/","page":"Overview","title":"Overview","text":"The PowerFlow module is the core analysis engine of the framework, providing multiple algorithms to solve different types of power flow problems, from traditional AC systems to modern hybrid AC/DC systems.","category":"page"},{"location":"modules/overview/#TimeDomainPowerFlow-Module","page":"Overview","title":"TimeDomainPowerFlow Module","text":"","category":"section"},{"location":"modules/overview/","page":"Overview","title":"Overview","text":"The TimeDomainPowerFlow module provides tools and functions for time-series power flow analysis, including dynamic dispatch, voltage profile analysis, and renewable integration.","category":"page"},{"location":"modules/overview/","page":"Overview","title":"Overview","text":"Key Features:","category":"page"},{"location":"modules/overview/","page":"Overview","title":"Overview","text":"Time-series power flow analysis\nDynamic dispatch optimization\nVoltage profile analysis\nRenewable energy integration\nVisualization capabilities","category":"page"},{"location":"modules/overview/","page":"Overview","title":"Overview","text":"The TimeDomainPowerFlow module extends traditional power flow analysis to handle time-varying system states, which is crucial for analyzing modern power system challenges such as renewable energy integration and demand response.","category":"page"},{"location":"modules/overview/#Application-Scenarios","page":"Overview","title":"Application Scenarios","text":"","category":"section"},{"location":"modules/overview/","page":"Overview","title":"Overview","text":"The TimeDomainPowerFlow framework is suitable for various power system analysis scenarios:","category":"page"},{"location":"modules/overview/","page":"Overview","title":"Overview","text":"Traditional Power System Analysis - Power flow calculation, fault analysis, and stability studies\nRenewable Energy Integration - Assessing the impact of renewable sources like PV and wind on the system\nHybrid AC/DC System Design - Optimizing HVDC transmission and hybrid microgrids\nEnergy Storage System Planning - Analyzing the performance and economics of large-scale energy storage systems\nCarbon Emission Assessment - Evaluating environmental impacts and emission reduction strategies\nTime-Series Optimization - Operational scheduling optimization based on time-varying carbon intensity","category":"page"},{"location":"modules/overview/#Technical-Features","page":"Overview","title":"Technical Features","text":"","category":"section"},{"location":"modules/overview/","page":"Overview","title":"Overview","text":"High-Performance Computing - Leveraging Julia's high-performance characteristics and GPU acceleration\nModular Design - Clear module structure for easy extension and customization\nComprehensive Documentation - Detailed API documentation and usage examples\nOpen-Source Ecosystem - Seamless integration with Julia's scientific computing ecosystem","category":"page"},{"location":"modules/overview/#Usage-Example","page":"Overview","title":"Usage Example","text":"","category":"section"},{"location":"modules/overview/","page":"Overview","title":"Overview","text":"Below is an example of using the HyDistFlow framework for basic power flow analysis:","category":"page"},{"location":"modules/overview/","page":"Overview","title":"Overview","text":"using HyDistFlow\n\n# Create power system model\ncase = JuliaPowerCase()\n\n# Add AC buses\nbus1 = Bus(1, \"Bus 1\", 110.0, \"b\", 1, 1.0, 0.0)\nbus2 = Bus(2, \"Bus 2\", 110.0, \"pq\", 1, 1.0, 0.0)\npush!(case.busesAC, bus1)\npush!(case.busesAC, bus2)\n\n# Add generator\ngen = StaticGenerator(1, \"Gen 1\", 1, 100.0, 20.0, 1.0, 150.0, 50.0, 50.0, -50.0)\npush!(case.sgensAC, gen)\n\n# Add line\nline = Line(1, \"Line 1-2\", 1, 2, 10.0, 0.1, 0.3, 10.0, 0.5, 1.0, 1)\npush!(case.branchesAC, line)\n\n# Add load\nload = Load(1, \"Load 1\", 2, 50.0, 10.0, 1.0, \"wye\")\npush!(case.loadsAC, load)\n\n# Convert to JPC format\njpc = JuliaPowerCase2Jpc(case)\n\n# Set power flow options\nopt = PowerFlow.settings()\nopt[:pf_alg] = :NR  # Newton-Raphson algorithm\nopt[:verbose] = 1\n\n# Run power flow\nresults = PowerFlow.runpf(jpc, opt)\n\n# Process results\nPowerFlow.process_result(results, case, opt)","category":"page"},{"location":"modules/overview/#Conclusion","page":"Overview","title":"Conclusion","text":"","category":"section"},{"location":"modules/overview/","page":"Overview","title":"Overview","text":"The HyDistFlow framework provides a comprehensive and efficient solution for modeling, simulating, and optimizing modern power systems. By combining Julia's high-performance characteristics with advanced power system analysis algorithms, the framework can handle a wide range of challenges from traditional AC systems to complex hybrid AC/DC systems. Whether for basic research, education, or engineering applications, HyDistFlow provides powerful and flexible tools to meet the needs of power system analysis.","category":"page"},{"location":"api/powerflow/#API-Reference","page":"PowerFlow API","title":"API Reference","text":"","category":"section"},{"location":"api/powerflow/#Power-Flow-Algorithm","page":"PowerFlow API","title":"Power Flow Algorithm","text":"","category":"section"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.adaptive_damped_newton","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.adaptive_damped_newton","text":"adaptive_damped_newton(baseMVA, bus, gen, load, pvarray, Ybus, V0, ref, p, tol0, max_it0, alg=\"\")\n\nSolve power flow using an adaptive damped Newton-Raphson method.\n\nThis function implements a Newton-Raphson method with adaptive damping factor to improve convergence in difficult cases. The damping factor is automatically adjusted based on the mismatch norm during iterations.\n\nArguments\n\nbaseMVA: Base MVA for the system\nbus: Bus data matrix\ngen: Generator data matrix\nload: Load data matrix\npvarray: PV array data\nYbus: Bus admittance matrix\nV0: Initial voltage vector\nref: Reference bus index\np: Vector of bus indices\ntol0: Convergence tolerance\nmax_it0: Maximum number of iterations\nalg: Linear solver algorithm (optional)\n\nReturns\n\nV: Final voltage solution vector\nconverged: Boolean indicating convergence status\ni: Number of iterations performed\n\n\n\n\n\n","category":"function"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.currentinjectionpf","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.currentinjectionpf","text":"currentinjectionpf(baseMVA, bus, gen, load, pvarray, Ybus, V0, ref, p, tol0, max_it0, alg=\"\")\n\nSolve power flow using the Current Injection method, particularly suitable for resistive networks.\n\nArguments\n\nbaseMVA: Base MVA for power system normalization\nbus: Matrix containing bus data\ngen: Matrix containing generator data\nload: Matrix containing load data\npvarray: Array of PV bus information\nYbus: Bus admittance matrix\nV0: Initial voltage vector\nref: Reference (slack) bus index\np: Array of PQ bus indices\ntol0: Convergence tolerance\nmax_it0: Maximum number of iterations\nalg: Algorithm variant (optional)\n\nReturns\n\nV: Final complex voltage vector solution\nconverged: Boolean indicating whether the algorithm converged\ni: Number of iterations performed\n\nDescription\n\nThis function implements the Current Injection power flow method, which is particularly effective for networks with high R/X ratios (resistive networks). The method works by:\n\nConverting power injections to current injections\nCalculating current mismatches\nSolving for voltage updates using the real part of the admittance matrix\nIterating until convergence or maximum iterations reached\n\n\n\n\n\n","category":"function"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.newtonpf","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.newtonpf","text":"newtonpf(baseMVA::Float64, bus::Matrix{Float64}, gen::Matrix{Float64}, \n         Ybus::SparseArrays.SparseMatrixCSC{ComplexF64}, V0::Vector{ComplexF64}, \n         ref::Vector{Int}, pv::Vector{Int}, pq::Vector{Int}, \n         tol0::Float64, max_it0::Int, alg::String=\"bicgstab\")\n\nSolve AC power flow using Newton-Raphson method.\n\nArguments\n\nbaseMVA: Base MVA for the system\nbus: Bus data matrix\ngen: Generator data matrix\nYbus: Bus admittance matrix\nV0: Initial voltage vector\nref: Reference bus indices\npv: PV bus indices\npq: PQ bus indices\ntol0: Convergence tolerance\nmax_it0: Maximum number of iterations\nalg: Algorithm specification for linear solver (default: \"bicgstab\")\n\nReturns\n\nV: Final voltage vector solution\nconverged: Boolean indicating whether the algorithm converged\ni: Number of iterations performed\nnorm_history: Array of norm values for each iteration\n\nDescription\n\nThis function implements the Newton-Raphson method to solve AC power flow equations. It iteratively updates voltage magnitudes and angles until the power mismatch falls below the specified tolerance or the maximum number of iterations is reached.\n\n\n\n\n\n","category":"function"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.newtonpf-2","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.newtonpf","text":"newtonpf(baseMVA::Float64, bus::Matrix{Float64}, gen::Matrix{Float64}, \n    load::Matrix{Float64}, pvarray, Ybus::SparseArrays.SparseMatrixCSC{ComplexF64}, V0::Vector{ComplexF64}, \n    ref::Vector{Int}, pv::Vector{Int}, pq::Vector{Int}, \n    tol0::Float64, max_it0::Int, alg::String=\"bicgstab\")\n\nSolve AC power flow using Newton-Raphson method with load and PV array models.\n\nArguments\n\nbaseMVA: Base MVA for the system\nbus: Bus data matrix\ngen: Generator data matrix\nload: Load data matrix\npvarray: PV array data\nYbus: Bus admittance matrix\nV0: Initial voltage vector\nref: Reference bus indices\npv: PV bus indices\npq: PQ bus indices\ntol0: Convergence tolerance\nmax_it0: Maximum number of iterations\nalg: Algorithm specification for linear solver (default: \"bicgstab\")\n\nReturns\n\nV: Final voltage vector solution\nconverged: Boolean indicating whether the algorithm converged\ni: Number of iterations performed\nnorm_history: Array of norm values for each iteration\n\nDescription\n\nThis function implements the Newton-Raphson method to solve AC power flow equations with load and PV array models. It iteratively updates voltage magnitudes and angles until the power mismatch falls below the specified tolerance or the maximum number of iterations is reached.\n\n\n\n\n\n","category":"function"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.newtonpf_gpu","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.newtonpf_gpu","text":"newtonpf_gpu(baseMVA, bus, gen, load, Ybus, V0, ref, pv, pq, tol0, max_it0, alg=\"gpuLU\")\n\nSolve AC power flow using Newton's method with GPU acceleration.\n\nArguments\n\nbaseMVA: Base MVA for the system\nbus: Bus data matrix\ngen: Generator data matrix\nload: Load data matrix\nYbus: Bus admittance matrix\nV0: Initial voltage vector\nref: Reference bus index\npv: Vector of PV bus indices\npq: Vector of PQ bus indices\ntol0: Convergence tolerance\nmax_it0: Maximum number of iterations\nalg: Algorithm specification for linear solver (default: \"gpuLU\")\n\nReturns\n\nV: Final voltage vector solution\nconverged: Boolean indicating whether the algorithm converged\ni: Number of iterations performed\n\nDescription\n\nThis function implements the Newton-Raphson method to solve AC power flow equations using GPU acceleration. It iteratively updates voltage magnitudes and angles until the power mismatch falls below the specified tolerance or the maximum number of iterations is reached.\n\nThe algorithm:\n\nInitializes voltage values and transfers data to GPU\nCalculates initial power mismatches\nConstructs the Jacobian matrix for each iteration\nUpdates voltage values using Newton's method\nChecks convergence based on power mismatch norm\n\nNotes\n\nThis implementation uses GPU acceleration for improved performance\nThe Jacobian matrix is constructed in block form with partial derivatives\nThe function handles both real and reactive power balance constraints\nData is transferred between CPU and GPU as needed for computation\n\n\n\n\n\n","category":"function"},{"location":"api/powerflow/#DC-Power-Flow-Algorithm","page":"PowerFlow API","title":"DC Power Flow Algorithm","text":"","category":"section"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.newtondcpf","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.newtondcpf","text":"newtondcpf(baseMVA, bus, gen, load, pvarray, Ybus, V0, ref, p, tol0, max_it0, alg=\"\")\n\nSolve DC power flow using Newton's method.\n\nArguments\n\nbaseMVA: Base MVA for the system\nbus: Bus data matrix\ngen: Generator data matrix\nload: Load data matrix\npvarray: PV array data\nYbus: Bus admittance matrix\nV0: Initial voltage vector\nref: Reference bus index\np: Vector of indices for buses to be included in the calculation\ntol0: Convergence tolerance\nmax_it0: Maximum number of iterations\nalg: Algorithm specification for linear solver (optional)\n\nReturns\n\nV: Final voltage vector solution\nconverged: Boolean indicating whether the algorithm converged\ni: Number of iterations performed\n\nDescription\n\nThis function implements the Newton-Raphson method to solve DC power flow equations. It iteratively updates voltage values until the power mismatch falls below the specified tolerance or the maximum number of iterations is reached.\n\nThe algorithm:\n\nInitializes voltage values from the provided starting point\nCalculates initial power mismatches\nConstructs the Jacobian matrix for each iteration\nUpdates voltage values using Newton's method\nChecks convergence based on power mismatch norm\n\nNotes\n\nThe Jacobian matrix represents the partial derivatives of power with respect to voltage\nThis implementation handles both real power balance constraints\n\n\n\n\n\n","category":"function"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.newtondcpf_sp","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.newtondcpf_sp","text":"newtondcpf_sp(baseMVA, bus, gen, load, pvarray, Ybus, V0, ref, p, tol0, max_it0, alg=\"\")\n\nSolve DC power flow using Newton's method with sparse matrices.\n\nArguments\n\nbaseMVA: Base MVA for the system\nbus: Bus data matrix\ngen: Generator data matrix\nload: Load data matrix\npvarray: PV array data\nYbus: Bus admittance matrix\nV0: Initial voltage vector\nref: Reference bus index\np: Vector of indices for buses to be included in the calculation\ntol0: Convergence tolerance\nmax_it0: Maximum number of iterations\nalg: Algorithm specification (optional)\n\nReturns\n\nV: Final voltage vector solution\nconverged: Boolean indicating whether the algorithm converged\ni: Number of iterations performed\n\nDescription\n\nThis function solves DC power flow using Newton's method. In DC systems,  power P = V * I, where I = G * V (G is the conductance matrix). The function  iteratively updates voltage magnitudes until the power mismatch falls below  the specified tolerance or the maximum number of iterations is reached.\n\nThe algorithm:\n\nInitializes voltage values from the provided starting point\nCalculates initial power mismatches\nConstructs the Jacobian matrix for each iteration\nUpdates voltage values using Newton's method\nChecks convergence based on power mismatch norm\n\nNotes\n\nFor DC systems, only active power is considered\nThe Jacobian matrix represents the partial derivatives of power with respect to voltage\n\n\n\n\n\n","category":"function"},{"location":"api/powerflow/#Linear-Problem-Solution-Algorithm","page":"PowerFlow API","title":"Linear Problem Solution Algorithm","text":"","category":"section"},{"location":"api/powerflow/#GPU-Acceleration","page":"PowerFlow API","title":"GPU Acceleration","text":"","category":"section"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.calculate_pv_power_gpu-NTuple{4, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.calculate_pv_power_gpu","text":"calculate_pv_power_gpu(pvarray_gpu, bus_gpu, Vm_gpu, baseMVA)\n\nCalculate power injections from PV arrays and their derivatives with respect to voltage magnitude using GPU acceleration.\n\nArguments\n\npvarray_gpu: PV array data matrix on GPU with columns representing PV parameters\nbus_gpu: Bus data matrix on GPU with columns representing bus parameters\nVm_gpu: Vector of bus voltage magnitudes on GPU\nbaseMVA: Base MVA for the system\n\nReturns\n\nSpv: Vector of complex power injections from PV arrays\ndSpv_dVm: Sparse matrix of partial derivatives of PV power injections with respect to voltage magnitude\n\nDescription\n\nThis function computes the power injections from PV arrays using a modified power function model that relates voltage to current output. It also calculates the derivatives of these injections with respect to voltage magnitude for use in power flow Jacobian calculations.\n\nThe function filters active PV arrays, maps them to their connected buses, and calculates their power output based on the current voltage conditions.\n\nNotes\n\nPower output is calculated using a modified power function model with parameters a, b, and c\nThe model accounts for the nonlinear relationship between voltage and current in PV arrays\nResults are converted to per-unit on system MVA base\nOnly real power is considered (no reactive power from PV arrays)\nCalculations are partially performed on CPU for complex operations\n\nConstants Used (assumed to be defined elsewhere)\n\nPVINSERVICE: Column index for PV array service status\nBUSI: Column index for bus number in busgpu matrix\nPVBUS: Column index for connected bus number in pvarraygpu matrix\nBASEKV: Column index for base voltage in busgpu matrix\nPVVOC: Column index for open circuit voltage in pvarraygpu matrix\nPVISC: Column index for short circuit current in pvarraygpu matrix\nPVAREA: Column index for PV array area in pvarraygpu matrix\nPVVMPP: Column index for maximum power point voltage in pvarraygpu matrix\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.create_bus_mapping-Tuple{Any, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.create_bus_mapping","text":"create_bus_mapping(bus_gpu, BUS_I)\n\nCreate a mapping dictionary from bus numbers to their indices in the bus matrix.\n\nArguments\n\nbus_gpu: Bus data matrix on GPU with columns representing bus parameters\nBUS_I: Column index for bus number in bus_gpu matrix\n\nReturns\n\nbus_to_idx: Dictionary mapping bus numbers to their indices in the bus matrix\n\nDescription\n\nThis function creates a dictionary that maps bus identification numbers to their  corresponding indices in the bus matrix. This mapping is useful for quickly finding the position of a specific bus in the data structures.\n\nNotes\n\nThe function transfers bus data from GPU to CPU for processing\nBus numbers may not be sequential or start from 1, hence the need for this mapping\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.find_bus_indices-Tuple{Any, Any, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.find_bus_indices","text":"find_bus_indices(bus_to_idx, active_pv, PV_BUS)\n\nFind the indices of buses to which PV arrays are connected.\n\nArguments\n\nbus_to_idx: Dictionary mapping bus numbers to their indices in the bus matrix\nactive_pv: PV array data matrix with columns representing PV parameters\nPV_BUS: Column index for connected bus number in active_pv matrix\n\nReturns\n\nvalid_pv: Boolean array indicating which PV arrays are connected to valid buses\nbus_indices: Array of bus indices corresponding to each valid PV array\n\nDescription\n\nThis function identifies which buses in the system have PV arrays connected to them. It returns a boolean mask indicating which PV arrays are connected to valid buses, and an array of the corresponding bus indices for those valid connections.\n\nNotes\n\nThe function processes data entirely on CPU for better dictionary lookup performance\nPV arrays connected to non-existent buses are marked as invalid\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.makeSbus_gpu-NTuple{7, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.makeSbus_gpu","text":"makeSbus_gpu(baseMVA, bus_gpu, gen_gpu, gen, Vm_gpu, load_gpu, pvarray_gpu; dc=false, Sg=nothing, return_derivative=false)\n\nBuild the vector of complex bus power injections using GPU acceleration.\n\nArguments\n\nbaseMVA: Base MVA for the system\nbus_gpu: Bus data matrix on GPU with columns representing bus parameters\ngen_gpu: Generator data matrix on GPU with columns representing generator parameters\ngen: Generator data matrix on CPU with columns representing generator parameters\nVm_gpu: Vector of bus voltage magnitudes on GPU\nload_gpu: Load data matrix on GPU with columns representing load parameters\npvarray_gpu: PV array data matrix on GPU with columns representing PV parameters\n\nKeyword Arguments\n\ndc: Boolean indicating whether to use DC power flow assumptions (default: false)\nSg: Optional pre-computed generator complex power injections (default: nothing)\nreturn_derivative: Boolean indicating whether to return derivative of Sbus with respect to Vm (default: false)\n\nReturns\n\nIf return_derivative=false: Vector of complex bus power injections (Sbus)\nIf return_derivative=true: Sparse matrix of partial derivatives of power injections with respect to voltage magnitude (dSbus_dVm)\n\nDescription\n\nThis function computes the vector of complex bus power injections (Sbus) for power flow analysis using GPU acceleration. It accounts for ZIP load models (constant power, constant current, and constant impedance components), generator injections, and PV array injections.\n\nWhen return_derivative=true, it returns the partial derivatives of the power injections with respect to voltage magnitude, which is useful for power flow Jacobian calculations.\n\nNotes\n\nAll power values are converted to per-unit on system MVA base\nThe function handles ZIP load models with percentages specified in load_gpu\nGenerator status is considered when computing injections\nWhen dc=true, voltage magnitudes are set to 1.0 p.u.\nPV array injections are calculated separately and added to the total bus injections\n\nConstants Used (assumed to be defined elsewhere)\n\nLOADCND: Column index for load bus number in loadgpu matrix\nLOADPPERCENT: Column index for constant power percentage in loadgpu matrix\nLOADIPERCENT: Column index for constant current percentage in loadgpu matrix\nLOADZPERCENT: Column index for constant impedance percentage in loadgpu matrix\nGEN_STATUS: Column index for generator status in gen matrix\nGEN_BUS: Column index for generator bus number in gen matrix\nPG: Column index for real power output in gen_gpu matrix\nQG: Column index for reactive power output in gen_gpu matrix\nPVINSERVICE: Column index for PV array service status in pvarray_gpu matrix\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.process_pv_connections-NTuple{4, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.process_pv_connections","text":"process_pv_connections(bus_gpu, active_pv, BUS_I, PV_BUS)\n\nProcess the connections between PV arrays and buses in the power system.\n\nArguments\n\nbus_gpu: Bus data matrix on GPU with columns representing bus parameters\nactive_pv: PV array data matrix with columns representing PV parameters\nBUS_I: Column index for bus number in bus_gpu matrix\nPV_BUS: Column index for connected bus number in active_pv matrix\n\nReturns\n\nvalid_pv: Boolean array indicating which PV arrays are connected to valid buses\nbus_indices: Array of bus indices corresponding to each valid PV array\n\nDescription\n\nThis function coordinates the process of mapping PV arrays to their connected buses in the power system. It creates a mapping from bus numbers to indices, then uses this mapping to identify which PV arrays are connected to valid buses in the system.\n\nNotes\n\nThis is a wrapper function that calls createbusmapping and findbusindices\nThe function handles the complete process of validating PV-to-bus connections\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Sd_gpu","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Sd_gpu","text":"Sd_gpu\n\nA mutable structure to store ZIP load model components on GPU.\n\nFields\n\nz: Complex vector on GPU representing constant impedance component of load\ni: Complex vector on GPU representing constant current component of load\np: Complex vector on GPU representing constant power component of load\n\nThis structure is used to store the components of the ZIP load model in GPU memory for efficient power flow calculations.\n\n\n\n\n\n","category":"type"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.makeSdzip_gpu-NTuple{5, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.makeSdzip_gpu","text":"makeSdzip_gpu(baseMVA, bus_gpu, pw_1, pw_2, pw_3)\n\nCreate a ZIP load model structure on GPU from bus data and ZIP percentages.\n\nArguments\n\nbaseMVA: Base MVA for the system\nbus_gpu: Bus data matrix on GPU with columns representing bus parameters\npw_1: Vector of constant power percentages for active power\npw_2: Vector of constant current percentages for active power\npw_3: Vector of constant impedance percentages for active power\n\nReturns\n\nsd: An Sd_gpu structure containing the ZIP load model components\n\nDescription\n\nThis function creates a ZIP (constant impedance, constant current, constant power) load model on the GPU for power flow calculations. It converts the load data from the bus matrix to per-unit values based on the system MVA base and the specified percentages for each component.\n\nThe function assumes that the same percentage distribution applies to both active and reactive power, so it uses the same percentages (pw1, pw2, pw_3) for both P and Q components.\n\nNotes\n\nAll power values are converted to per-unit on system MVA base\nPD and QD columns in bus_gpu represent the total active and reactive power demand\npw1, pw2, pw_3 represent the percentages of constant power, constant current, and constant impedance components\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#Other-Functions","page":"PowerFlow API","title":"Other Functions","text":"","category":"section"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.calculate_pv_power-NTuple{4, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.calculate_pv_power","text":"calculate_pv_power(pvarray, bus, Vm, baseMVA)\n\nCalculate power injection from PV arrays and its derivative with respect to voltage magnitude.\n\nArguments\n\npvarray: PV array data matrix with columns representing PV parameters\nbus: Bus data matrix with columns representing bus parameters\nVm: Vector of bus voltage magnitudes\nbaseMVA: Base MVA for the system\n\nReturns\n\nSpv: Vector of complex power injections from PV arrays\ndSpv_dVm: Sparse matrix of partial derivatives of PV power injections with respect to voltage magnitude\n\nDescription\n\nThis function calculates the power injection from PV arrays based on a modified power function model that accounts for the PV array characteristics including open circuit voltage, short circuit current, and maximum power point voltage. It also computes the derivatives of these injections with respect to bus voltage magnitudes, which are needed for power flow Jacobian calculations.\n\nThe PV model uses a modified power function with correction terms to better represent the current-voltage characteristics of PV panels: I = Isc * (1 - (V/Voc)^a)^b * (1 - c * ((V/Vmpp) - 1)^2)\n\nNotes\n\nOnly active PV arrays (PVINSERVICE > 0) are considered\nThe function maps PV arrays to their respective buses using the bus numbering\nPower output is converted to per-unit on system MVA base\nOnly real power (no reactive power) is considered for PV arrays\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.makeSbus","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.makeSbus","text":"makeSbus(baseMVA, bus, gen, Vm, Sg=nothing, return_derivative=false)\n\nBuild the vector of complex bus power injections (simplified version without PV arrays).\n\nArguments\n\nbaseMVA: Base MVA for the system\nbus: Bus data matrix with columns representing bus parameters\ngen: Generator data matrix with columns representing generator parameters\nVm: Vector of bus voltage magnitudes\n\nKeyword Arguments\n\nSg: Optional pre-computed generator complex power injections (default: nothing)\nreturn_derivative: Boolean indicating whether to return derivative of Sbus with respect to Vm (default: false)\n\nReturns\n\nIf return_derivative=false: Vector of complex bus power injections (Sbus)\nIf return_derivative=true: Sparse matrix of partial derivatives of power injections with respect to voltage magnitude (dSbus_dVm)\n\nDescription\n\nThis is a simplified version of the makeSbus function that does not include PV array contributions. It computes the vector of complex bus power injections (Sbus) for power flow analysis, accounting for ZIP load models and generator injections.\n\n\n\n\n\n","category":"function"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.makeSbus-Tuple{Any, Any, Any, Any, Matrix{Float64}, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.makeSbus","text":"makeSbus(baseMVA, bus, gen, Vm, load::Matrix{Float64}, pvarray; dc=false, Sg=nothing, return_derivative=false)\n\nBuild the vector of complex bus power injections, including PV array contributions.\n\nArguments\n\nbaseMVA: Base MVA for the system\nbus: Bus data matrix with columns representing bus parameters\ngen: Generator data matrix with columns representing generator parameters\nVm: Vector of bus voltage magnitudes\nload: Load data matrix with columns representing load parameters\npvarray: PV array data matrix with columns representing PV parameters\n\nKeyword Arguments\n\ndc: Boolean indicating whether to use DC power flow assumptions (default: false)\nSg: Optional pre-computed generator complex power injections (default: nothing)\nreturn_derivative: Boolean indicating whether to return derivative of Sbus with respect to Vm (default: false)\n\nReturns\n\nIf return_derivative=false: Vector of complex bus power injections (Sbus)\nIf return_derivative=true: Sparse matrix of partial derivatives of power injections with respect to voltage magnitude (dSbus_dVm)\n\nDescription\n\nThis function computes the vector of complex bus power injections (Sbus) for power flow analysis. It accounts for ZIP load models, generator injections, and PV array contributions.\n\nWhen return_derivative=true, it returns the partial derivatives of the power injections with respect to voltage magnitude, which is useful for power flow Jacobian calculations.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Sd","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.Sd","text":"Sd\n\nA mutable structure to store ZIP load model components.\n\nFields\n\nz: Complex vector representing constant impedance component of load\ni: Complex vector representing constant current component of load\np: Complex vector representing constant power component of load\n\nThis structure is used to store the components of the ZIP load model for efficient power flow calculations.\n\n\n\n\n\n","category":"type"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.makeSdzip-NTuple{5, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.makeSdzip","text":"makeSdzip(baseMVA, bus, pw_1, pw_2, pw_3)\n\nCreate a ZIP load model structure from bus data and specified ZIP percentages.\n\nArguments\n\nbaseMVA: Base MVA for the system\nbus: Bus data matrix with columns representing bus parameters\npw_1: Vector of constant power percentages for active power\npw_2: Vector of constant current percentages for active power\npw_3: Vector of constant impedance percentages for active power\n\nReturns\n\nsd: An Sd structure containing the ZIP load model components\n\nDescription\n\nThis function creates a ZIP (constant impedance, constant current, constant power) load model for power flow calculations. It converts the load data from the bus matrix to per-unit values based on the system MVA base and the specified percentages for each component.\n\nThe function assumes that the same percentage distribution applies to both active and reactive power, so it uses the same percentages (pw1, pw2, pw_3) for both P and Q components.\n\nNotes\n\nAll power values are converted to per-unit on system MVA base\nPD and QD columns in bus represent the total active and reactive power demand\npw1, pw2, pw_3 represent the percentages of constant power, constant current, and constant impedance components\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.makeSdzip-Tuple{Any, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.makeSdzip","text":"makeSdzip(baseMVA, bus)\n\nCreate a ZIP load model structure from bus data with default constant power model.\n\nArguments\n\nbaseMVA: Base MVA for the system\nbus: Bus data matrix with columns representing bus parameters\n\nReturns\n\nsd: An Sd structure containing the ZIP load model components\n\nDescription\n\nThis is a simplified version of the makeSdzip function that assumes a constant power model (100% constant power, 0% constant current, 0% constant impedance).\n\nNotes\n\nAll power values are converted to per-unit on system MVA base\nPD and QD columns in bus represent the total active and reactive power demand\nBy default, all load is modeled as constant power (P-Q) load\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.makeYbus-Tuple{Any, Any, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.makeYbus","text":"makeYbus(baseMVA, bus, branch)\n\nBuild the bus admittance matrix and branch admittance matrices.\n\nArguments\n\nbaseMVA: Base MVA for the system\nbus: Bus data matrix with columns representing bus parameters\nbranch: Branch data matrix with columns representing branch parameters\n\nReturns\n\nYbus: Bus admittance matrix\nYf: Branch admittance matrix for \"from\" end of branches\nYt: Branch admittance matrix for \"to\" end of branches\n\nDescription\n\nThis function builds the bus admittance matrix (Ybus) and branch admittance matrices (Yf and Yt) for a given power system network. The admittance matrices are essential components for power flow and other power system analyses.\n\nThe function:\n\nComputes branch series admittances and line charging susceptances\nHandles tap ratios and phase shifters\nIncorporates bus shunt admittances\nBuilds connection matrices between branches and buses\nConstructs the complete bus admittance matrix\n\nNotes\n\nAll admittance values are in per-unit on system MVA base\nRequires buses to be numbered consecutively (internal ordering)\nBranch status values determine which branches are in service\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.merge_results-Tuple{Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.merge_results","text":"merge_results(results)\n\nMerge power flow calculation results from multiple isolated islands.\n\nArguments\n\nresults: An array of JPC objects containing power flow results for different islands\n\nReturns\n\nmerged_result: A single JPC object containing the combined results\narea: The number of islands that were merged\n\nDescription\n\nThis function combines power flow results from multiple isolated islands into a single comprehensive result. It merges all data matrices (buses, branches, generators, etc.) from the individual island results and sorts them by their ID numbers.\n\nThe function:\n\nCreates a new JPC object to hold the merged results\nCombines basic result fields like success status and iteration counts\nMerges all data matrices from the input results\nSorts the merged matrices by their first column (typically ID numbers)\n\nNotes\n\nAssumes all input results use the same base MVA\nSuccess is determined by the logical AND of all individual results' success flags\nIteration count is the maximum of all individual results' iteration counts\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.extract_bus_data-Tuple{JPC}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.extract_bus_data","text":"Extract bus data from your data structure\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.generate_matpower_report","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.generate_matpower_report","text":"Format power flow calculation results as MATPOWER-style report and save to a text file\n\n\n\n\n\n","category":"function"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.write_branch_data-Tuple{IOStream, JPC}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.write_branch_data","text":"Write branch data section\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.write_bus_data-Tuple{IOStream, JPC, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.write_bus_data","text":"Write bus data section\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.write_system_summary-Tuple{IOStream, JPC, Any, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.write_system_summary","text":"Write system summary section\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.dcpfsoln-Tuple{Float64, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Vararg{Any, 6}}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.dcpfsoln","text":"dcpfsoln(baseMVA::Float64, bus0::Matrix{Float64}, gen0::Matrix{Float64}, \n         branch0::Matrix{Float64}, load0::Matrix{Float64}, Ybus, Yf, Yt, V, ref, p)\n\nUpdate power system state variables after a DC power flow solution.\n\nArguments\n\nbaseMVA::Float64: Base MVA value for the system\nbus0::Matrix{Float64}: Initial bus data matrix\ngen0::Matrix{Float64}: Initial generator data matrix\nbranch0::Matrix{Float64}: Initial branch data matrix\nload0::Matrix{Float64}: Load data matrix\nYbus: Bus admittance matrix\nYf: From-bus branch admittance matrix\nYt: To-bus branch admittance matrix\nV: Complex bus voltage vector solution\nref: Reference (slack) bus indices\np: P bus indices\n\nReturns\n\nbus: Updated bus data matrix\ngen: Updated generator data matrix\nbranch: Updated branch data matrix with power flows\n\nDescription\n\nThis function updates the power system state variables after a DC power flow solution has been obtained. It performs the following operations:\n\nUpdates bus voltage magnitudes\nUpdates generator reactive power (Qg) for generators at PV and slack buses\nDistributes reactive power proportionally among multiple generators at the same bus\nRespects generator reactive power limits\nUpdates active power (Pg) for generators at slack buses\nCalculates branch power flows\nExpands the branch matrix if needed to store power flow results\n\nThe function handles special cases like multiple generators at the same bus and generators with identical reactive power limits.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.pfsoln-Tuple{Float64, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Vararg{Any, 7}}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.pfsoln","text":"Update power flow solution with computed voltage values and calculate generator outputs and branch flows. For the version with load data as a separate parameter.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.pfsoln-Tuple{Float64, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Vararg{Any, 7}}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.pfsoln","text":"Update power flow solution with computed voltage values and calculate generator outputs and branch flows. Standard version without separate load data parameter.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.process_result-Tuple{Any, Any, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.process_result","text":"Process power flow calculation results and generate a report. This function merges results, extracts execution time, and creates a MATPOWER format report.\n\nParameters:\n\nresults: Array containing calculation results and timing information\nisolated: Information about isolated parts of the network\nfile_path: Path where the report will be saved\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.analyze_voltage_results-Tuple{NamedTuple, JuliaPowerCase, String}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.analyze_voltage_results","text":"analyze_voltage_results(results::NamedTuple, case::JuliaPowerCase, reference_file::String;\n                       tolerance_mag::Float64=1e-4, tolerance_ang::Float64=1e-3,\n                       output_dir::String=\"./results\", save_pdf::Bool=true)\n\nAnalyze voltage differences between power flow calculation results and reference file, generate comparison reports and charts. Supports both original format and AC/DC mixed format. Parameters:\n\nresults: NamedTuple containing results in JPC format (typically the return value of power flow calculation)\ncase: Original JuliaPowerCase object, used to get node names and ID mappings\nreference_file: Path to Excel file containing reference voltage values\ntolerance_mag: Tolerance for voltage magnitude comparison (default: 1e-4)\ntolerance_ang: Tolerance for voltage angle comparison (default: 1e-3)\noutput_dir: Output directory (default: \"./results\")\nsave_pdf: Whether to save plots in PDF format in addition to PNG (default: true)\n\nReturns:\n\nDataFrame or NamedTuple containing comparison results\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.compare_voltage_results-Tuple{NamedTuple, JuliaPowerCase, String}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.compare_voltage_results","text":"compare_voltage_results(results::NamedTuple, case::JuliaPowerCase, reference_file::String; \n                       tolerance_mag::Float64=1e-4, tolerance_ang::Float64=1e-3)\n\nCompare power flow calculation results in JPC format with reference voltage values, using JuliaPowerCase for node mapping. Supports both original format and new format with mixed AC/DC data. Parameters:\n\nresults: NamedTuple containing results in JPC format (typically the return value of power flow calculation)\ncase: Original JuliaPowerCase object, used to get node names and ID mappings\nreference_file: Path to Excel file containing reference voltage values\ntolerance_mag: Tolerance for voltage magnitude comparison (default: 1e-4)\ntolerance_ang: Tolerance for voltage angle comparison (default: 1e-3)\n\nReturns:\n\nNamedTuple containing comparison results, including ac and dc DataFrames\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_bus_voltage_results-Tuple{NamedTuple, JuliaPowerCase}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_bus_voltage_results","text":"get_bus_voltage_results(results::NamedTuple, case::JuliaPowerCase)\n\nExtract bus voltage information from power flow calculation results in JPC format, and map to node names in JuliaPowerCase. Parameters:\n\nresults: NamedTuple containing results in JPC format (typically the return value of power flow calculation)\ncase: Original JuliaPowerCase object, used to get node names and ID mappings\n\nReturns:\n\nDataFrame containing bus voltage results\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_bus_voltage_results_acdc-Tuple{NamedTuple, JuliaPowerCase}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_bus_voltage_results_acdc","text":"get_bus_voltage_results_acdc(results::NamedTuple, case::JuliaPowerCase)\n\nExtract both AC and DC bus voltage information from power flow calculation results in JPC format, and map to node names in JuliaPowerCase. Parameters:\n\nresults: NamedTuple containing results in JPC format (typically the return value of power flow calculation)\ncase: Original JuliaPowerCase object, used to get node names and ID mappings\n\nReturns:\n\nNamedTuple containing AC and DC bus voltage results as two DataFrames: ac and dc\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.plot_voltage_comparison","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.plot_voltage_comparison","text":"plot_voltage_comparison(comparison_results, output_file::String=\"voltage_comparison.png\";\n                       show_plot::Bool=true)\n\nPlot voltage magnitude and angle comparison curves between calculated and reference values. Supports both original format and AC/DC mixed format. Parameters:\n\ncomparison_results: Can be a DataFrame or a NamedTuple containing ac and dc DataFrames\noutputfile: Path to save the chart file (default: \"voltagecomparison.png\")\nshow_plot: Whether to display the chart (default: true)\n\nReturns:\n\nGenerated chart object or NamedTuple containing chart objects\n\n\n\n\n\n","category":"function"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.plot_voltage_errors","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.plot_voltage_errors","text":"plot_voltage_errors(comparison_results, output_file::String=\"voltage_errors.png\";\n                   show_plot::Bool=true)\n\nPlot voltage magnitude and angle error curves. Supports both original format and AC/DC mixed format. Parameters:\n\ncomparison_results: Can be a DataFrame or a NamedTuple containing ac and dc DataFrames\noutputfile: Path to save the chart file (default: \"voltageerrors.png\")\nshow_plot: Whether to display the chart (default: true)\n\nReturns:\n\nGenerated chart object or NamedTuple containing chart objects\n\n\n\n\n\n","category":"function"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.save_comparison_results-Tuple{Any, String}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.save_comparison_results","text":"save_comparison_results(comparison_results, output_file::String)\n\nSave comparison results to an Excel file. Supports both original format and AC/DC mixed format. Parameters:\n\ncomparison_results: Can be a DataFrame or a NamedTuple containing ac and dc DataFrames\noutput_file: Output file path\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.rundcpf-Tuple{Any, Dict{String}}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.rundcpf","text":"Main function to call the DC power flow function     Input: case file     Output: results of the power flow as a dictionary     Example:     bus, gen, branch = rundcpf(casefile)\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.calculate_droop_voltage","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.calculate_droop_voltage","text":"calculate_droop_voltage(P_dc, k_p, U_dc_ref=1.0, U_dc_min=0.95, U_dc_max=1.05)\n\nCalculate DC voltage with droop control using the equation: Udc = Udcref - kp * P_dc Limits the output voltage to be within specified minimum and maximum values.\n\nParameters:\n\nP_dc: DC power\nk_p: Droop coefficient\nUdcref: Reference DC voltage (default: 1.0 p.u.)\nUdcmin: Minimum allowed DC voltage (default: 0.95 p.u.)\nUdcmax: Maximum allowed DC voltage (default: 1.05 p.u.)\n\nReturns:\n\nLimited DC voltage value\n\n\n\n\n\n","category":"function"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.runhpf-Tuple{Any, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.runhpf","text":"runhpf(jpc, opt)\n\nRun hybrid power flow calculation for integrated AC/DC systems. Iteratively solves AC and DC power flow while updating converter power exchanges. Supports different converter control modes.\n\nParameters:\n\njpc: JPC object containing both AC and DC system data\nopt: Options for power flow calculation\n\nReturns:\n\nUpdated JPC object with power flow results\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.update_ac_load!-NTuple{4, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.update_ac_load!","text":"update_ac_load!(result_jpc, jpc1, ac_bus_id, P_ac)\n\nHelper function to update AC side load with power from converter. Creates a new load if none exists at the specified bus.\n\nParameters:\n\nresult_jpc: Main JPC object containing all system data\njpc1: JPC object for AC system\nacbusid: ID of the AC bus to update\nP_ac: AC power to add to the load\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.update_dc_load!-NTuple{4, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.update_dc_load!","text":"update_dc_load!(result_jpc, jpc2, dc_bus_id, P_dc)\n\nHelper function to update DC side load with power from converter. Creates a new load if none exists at the specified bus.\n\nParameters:\n\nresult_jpc: Main JPC object containing all system data\njpc2: JPC object for DC system\ndcbusid: ID of the DC bus to update\nP_dc: DC power to add to the load\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.update_mode_1_converters!-NTuple{4, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.update_mode_1_converters!","text":"update_mode_1_converters!(result_jpc, jpc1, jpc2, current_power_values)\n\nUpdate converters with mode constant δs, Us (CONV_MODE==1). These converters have fixed AC voltage angle and magnitude, and the power is calculated from AC side.\n\nParameters:\n\nresult_jpc: Main JPC object containing all system data\njpc1: JPC object for AC system\njpc2: JPC object for DC system\ncurrentpowervalues: Dictionary to store current power values for convergence check\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.update_mode_3_converters!-NTuple{4, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.update_mode_3_converters!","text":"update_mode_3_converters!(result_jpc, jpc1, jpc2, current_power_values)\n\nUpdate converters with mode constant Ps, Us (CONV_MODE==3). These converters have fixed active power and AC voltage magnitude.\n\nParameters:\n\nresult_jpc: Main JPC object containing all system data\njpc1: JPC object for AC system\njpc2: JPC object for DC system\ncurrentpowervalues: Dictionary to store current power values for convergence check\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.update_mode_4_converters!-NTuple{4, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.update_mode_4_converters!","text":"update_mode_4_converters!(result_jpc, jpc1, jpc2, current_power_values)\n\nUpdate converters with mode constant Udc, Qs (CONV_MODE==4). These converters have fixed DC voltage and reactive power.\n\nParameters:\n\nresult_jpc: Main JPC object containing all system data\njpc1: JPC object for AC system\njpc2: JPC object for DC system\ncurrentpowervalues: Dictionary to store current power values for convergence check\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.update_mode_5_converters!-NTuple{4, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.update_mode_5_converters!","text":"update_mode_5_converters!(result_jpc, jpc1, jpc2, current_power_values)\n\nUpdate converters with mode constant Udc, Us (CONV_MODE==5). These converters have fixed DC voltage and AC voltage magnitude.\n\nParameters:\n\nresult_jpc: Main JPC object containing all system data\njpc1: JPC object for AC system\njpc2: JPC object for DC system\ncurrentpowervalues: Dictionary to store current power values for convergence check\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.update_mode_6_converters!-NTuple{4, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.update_mode_6_converters!","text":"update_mode_6_converters!(result_jpc, jpc1, jpc2, current_power_values)\n\nUpdate converters with mode Droop Udc, Constant Qs (CONV_MODE==6). These converters use DC voltage droop control and maintain constant reactive power.\n\nParameters:\n\nresult_jpc: Main JPC object containing all system data\njpc1: JPC object for AC system\njpc2: JPC object for DC system\ncurrentpowervalues: Dictionary to store current power values for convergence check\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.update_mode_7_converters!-NTuple{4, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.update_mode_7_converters!","text":"update_mode_7_converters!(result_jpc, jpc1, jpc2, current_power_values)\n\nUpdate converters with mode Droop Udc, Constant Us (CONV_MODE==7). These converters use DC voltage droop control and maintain constant AC voltage magnitude.\n\nParameters:\n\nresult_jpc: Main JPC object containing all system data\njpc1: JPC object for AC system\njpc2: JPC object for DC system\ncurrentpowervalues: Dictionary to store current power values for convergence check\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.I0_from_V012-Tuple{Any, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.I0_from_V012","text":"I0_from_V012(V012, Y)\n\nCalculate zero sequence current from sequence voltages and admittance matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.I1_from_V012-Tuple{Any, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.I1_from_V012","text":"I1_from_V012(V012, Y)\n\nCalculate positive sequence current from sequence voltages and admittance matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.I2_from_V012-Tuple{Any, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.I2_from_V012","text":"I2_from_V012(V012, Y)\n\nCalculate negative sequence current from sequence voltages and admittance matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.I_from_SV_elementwise-Tuple{Any, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.I_from_SV_elementwise","text":"I_from_SV_elementwise(S, V)\n\nCalculate current from complex power and voltage: I = conj(S/V).\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.SVabc_from_SV012-Tuple{Any, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.SVabc_from_SV012","text":"SVabc_from_SV012(S012, V012; n_res=nothing, idx=nothing)\n\nConvert sequence components of power and voltage to phase components.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.S_from_VI_elementwise-Tuple{Any, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.S_from_VI_elementwise","text":"S_from_VI_elementwise(v, i)\n\nCalculate complex power from voltage and current: S = V * conj(I).\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.V1_from_jpc-Tuple{Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.V1_from_jpc","text":"V1_from_jpc(jpc)\n\nExtract positive sequence voltage from JPC structure.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.V_from_I-Tuple{Any, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.V_from_I","text":"V_from_I(Y, I)\n\nCalculate voltage from current using V = Y\\I.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow._clean_up","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow._clean_up","text":"_clean_up(net, res=true)\n\nClean up temporary data structures after power flow calculation.\n\n\n\n\n\n","category":"function"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow._get_p_q_gen_results_3ph-NTuple{5, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow._get_p_q_gen_results_3ph","text":"_get_p_q_gen_results_3ph(case, jpc_3ph, jpc0, jpc1, jpc2)\n\nCalculate active and reactive power for generators in three-phase system.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow._sum_by_group_nvals-Tuple{Any, Vararg{Any}}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow._sum_by_group_nvals","text":"_sum_by_group_nvals(bus, vals...)\n\nGroup values by bus and sum them within each group for multiple value arrays.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.combine_X012-Tuple{Any, Any, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.combine_X012","text":"combine_X012(X0, X1, X2)\n\nCombine zero, positive, and negative sequence components into one matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.current_from_voltage_results-Tuple{Any, Any, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.current_from_voltage_results","text":"current_from_voltage_results(y_0_pu, y_1_pu, v_012_pu)\n\nCalculate sequence currents from sequence voltages and admittance matrices.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.extratct_jpc_3ph-Tuple{HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_3ph}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.extratct_jpc_3ph","text":"extratct_jpc_3ph(jpc_3ph::PowerFlow.JPC_3ph)\n\nExtract individual sequence components from a three-phase JPC object.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_branch_flows_3ph-Tuple{Any, Any, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_branch_flows_3ph","text":"get_branch_flows_3ph(jpc0, jpc1, jpc2)\n\nCalculate branch flows for three-phase system.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_branch_results_3ph-NTuple{5, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_branch_results_3ph","text":"get_branch_results_3ph(jpc_3ph, jpc0, jpc1, jpc2, pq_buses)\n\nExtract branch results and write them to the appropriate dataframes.\n\nParameters:     results: result of runpf loadflow calculation     p: dict to store \"resline\" and \"restrafo\" Dataframes\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_bus_results_3ph-Tuple{Any, Any, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_bus_results_3ph","text":"get_bus_results_3ph(case, jpc_3ph, bus_pq)\n\nStore three-phase bus results in the appropriate fields.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_bus_v_results_3ph-NTuple{4, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_bus_v_results_3ph","text":"get_bus_v_results_3ph(jpc_3ph, jpc0, jpc1, jpc2)\n\nCalculate and store three-phase voltage results for all buses.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_elements-Tuple{Any, JuliaPowerCase, Any, Any, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_elements","text":"get_elements(params, case::JuliaPowerCase, element, phase, typ)\n\nThis function is used to get the elements of the load mapping. Automatically skips elements that don't exist in case.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_ext_grid_results_3ph-NTuple{5, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_ext_grid_results_3ph","text":"get_ext_grid_results_3ph(case, jpc_3ph, jpc0, jpc1, jpc2)\n\nCalculate and store three-phase external grid results.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_full_branch_zero-Tuple{Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_full_branch_zero","text":"get_full_branch_zero(jpc_3ph)\n\nAdd non-service branches to zero sequence branch data.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_gen_results_3ph-NTuple{6, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_gen_results_3ph","text":"get_gen_results_3ph(case, jpc_3ph, jpc0, jpc1, jpc2, pq_bus)\n\nCalculate and store three-phase generator results.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_internal_variables-Tuple{JPC}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_internal_variables","text":"get_internal_variables(jpc::JPC)\n\nRetrieve stored internal variables for a JPC object.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_p_q_b","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_p_q_b","text":"get_p_q_b(case, jpc_3ph, element, suffix=nothing)\n\nGet active and reactive power values and bus indices for a specific element.\n\n\n\n\n\n","category":"function"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_p_q_b_3ph-Tuple{Any, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_p_q_b_3ph","text":"get_p_q_b_3ph(net, element)\n\nGet three-phase active and reactive power values and bus indices for a specific element.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_p_q_results_3ph-Tuple{Any, HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_3ph}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_p_q_results_3ph","text":"get_p_q_results_3ph(case, jpc_3ph::PowerFlow.JPC_3ph)\n\nCalculate and aggregate active and reactive power results for three-phase system.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_pf_variables_from_JPC-Tuple{JPC}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_pf_variables_from_JPC","text":"get_pf_variables_from_JPC(jpc::JPC)\n\nExtract power flow variables from JPC structure.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_pp_gen_results_3ph-NTuple{12, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_pp_gen_results_3ph","text":"get_pp_gen_results_3ph(case, jpc_3ph, jpc0, jpc1, jpc2, b, pA, qA, pB, qB, pC, qC)\n\nCalculate and store three-phase generator results.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_y_bus-Tuple{Any, Any, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_y_bus","text":"get_y_bus(jpc0, jpc1, jpc2)\n\nBuild admittance matrices for zero, positive, and negative sequence networks.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.load_mapping-Tuple{JuliaPowerCase, JPC}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.load_mapping","text":"load_mapping(case::JuliaPowerCase, jpc1::JPC)\n\nMaps loads from the case to the power flow model, handling both wye and delta connections for all three phases.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.phase_shift_unit_operator-Tuple{Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.phase_shift_unit_operator","text":"phase_shift_unit_operator(angle_deg)\n\nCreate a complex number representing a phase shift of the given angle in degrees.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.phase_to_sequence-Tuple{Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.phase_to_sequence","text":"phase_to_sequence(Xabc)\n\nTransform phase components (a, b, c) to sequence components (zero, positive, negative).\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.robust_process-Tuple{Any, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.robust_process","text":"robust_process(net, jpc)\n\nProcess network and JPC data to ensure robust operation.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.run_newton_raphson_pf-Tuple{JPC, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.run_newton_raphson_pf","text":"run_newton_raphson_pf(jpc::JPC, opt)\n\nRun Newton-Raphson power flow calculation.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.runupf-NTuple{5, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.runupf","text":"runupf(case, jpc_3ph, gs_eg, bs_eg, opt)\n\nThis function is used to run a local unbalanced power flow analysis on unsymmetrical load nodes\n\n#Step1: find the unbalanced nodes in the system #Step2: find the interface branches of the unbalanced nodes and balanced nodes\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.sequence_to_phase-Tuple{Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.sequence_to_phase","text":"sequence_to_phase(X012)\n\nTransform sequence components (zero, positive, negative) to phase components (a, b, c).\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.sum_by_group-Tuple{Any, Any, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.sum_by_group","text":"sum_by_group(bus, first_val, second_val)\n\nGroup values by bus and sum them within each group.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.write_pq_results_to_element","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.write_pq_results_to_element","text":"write_pq_results_to_element(case, jpc_3ph, element, suffix=nothing)\n\nWrite power results to the specified element in jpc_3ph.\n\n\n\n\n\n","category":"function"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.write_pq_results_to_element_3ph-Tuple{Any, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.write_pq_results_to_element_3ph","text":"write_pq_results_to_element_3ph(net, element)\n\nGet pmw and qmvar for a specific pq element (\"load\", \"sgen\"...). This function basically writes values from element table to res_element table.\n\nParameters:     net: pandapower network     element: element name (str) Returns:     net with updated results\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.total_load-Tuple{Any, Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.total_load","text":"total_load(bus, load)\n\nCalculate the total fixed and dispatchable load at each bus in the system, considering ZIP load model.\n\nArguments\n\nbus: Bus data matrix containing bus information\nload: Load data matrix containing load model percentages\n\nReturns\n\nPd: Vector of real power demand at each bus\nQd: Vector of reactive power demand at each bus (if want_Q=1)\n\nThis function computes the total load at each bus using the ZIP load model, which represents loads as a combination of constant impedance (Z), constant current (I), and constant power (P) components. The percentages for each component are specified in the load matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow/#HyDistFlow.TimeDomainPowerFlow.PowerFlow.total_load-Tuple{Any}","page":"PowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.PowerFlow.total_load","text":"total_load(bus)\n\nCalculate the total fixed and dispatchable load at each bus in the system using default ZIP parameters.\n\nArguments\n\nbus: Bus data matrix containing bus information\n\nReturns\n\nPd: Vector of real power demand at each bus\nQd: Vector of reactive power demand at each bus (if want_Q=1)\n\nThis is an overloaded version of total_load that uses default ZIP model parameters. It computes the total load at each bus using the standard ZIP load model with default percentages for constant impedance (Z), constant current (I), and constant power (P) components.\n\n\n\n\n\n","category":"method"},{"location":"api/hydistflow/#API-Reference","page":"HyDistFlow API","title":"API Reference","text":"","category":"section"},{"location":"api/hydistflow/#HyDistFlow.HyDistFlow","page":"HyDistFlow API","title":"HyDistFlow.HyDistFlow","text":"HyDistFlow\n\nModule for hybrid AC/DC Distribution system analysis.\n\n\n\n\n\n","category":"module"},{"location":"api/hydistflow/#Core-Module","page":"HyDistFlow API","title":"Core Module","text":"","category":"section"},{"location":"modules/timedomainpowerflow/#TimeDomainPowerFlow-Module","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow Module","text":"","category":"section"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"The TimeDomainPowerFlow module provides tools and functions for time-series power flow analysis in power systems, including dynamic dispatch, voltage profile analysis, and renewable integration.","category":"page"},{"location":"modules/timedomainpowerflow/#Module-Overview","page":"TimeDomainPowerFlow","title":"Module Overview","text":"","category":"section"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"module TimeDomainPowerFlow\n\n    using Printf\n    using SparseArrays\n    using Plots\n    using Statistics\n    using DataFrames\n    using XLSX\n    using Dates\n\n    # Module exports and includes\n    # ...\nend","category":"page"},{"location":"modules/timedomainpowerflow/#Flow-Chart","page":"TimeDomainPowerFlow","title":"Flow Chart","text":"","category":"section"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"(Image: TimeDomainPowerFlow flow chart)","category":"page"},{"location":"modules/timedomainpowerflow/#Time-Series-Data-Processing","page":"TimeDomainPowerFlow","title":"Time Series Data Processing","text":"","category":"section"},{"location":"modules/timedomainpowerflow/#Reading-Load-Data","page":"TimeDomainPowerFlow","title":"Reading Load Data","text":"","category":"section"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"read_load_data(file_path)","category":"page"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"Read load time series data from an Excel file.","category":"page"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"Arguments:","category":"page"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"file_path: Path to the Excel file containing load data","category":"page"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"Returns:","category":"page"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"time_column: Vector containing time values from the first column\ntime_str_column: Vector containing time string representations from the second column\nload_names: Vector of load names extracted from column headers\ndata: DataFrame containing the entire load dataset","category":"page"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"This function reads load time series data from an Excel file into a DataFrame. It extracts the time values, time string representations, and the names of the loads from the column headers.","category":"page"},{"location":"modules/timedomainpowerflow/#Simulation-Functions","page":"TimeDomainPowerFlow","title":"Simulation Functions","text":"","category":"section"},{"location":"modules/timedomainpowerflow/#Run-Single-Day-Simulation","page":"TimeDomainPowerFlow","title":"Run Single Day Simulation","text":"","category":"section"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"run_single_day(old_jpc, opt, day_load_matrix, day_price_line, day_irradiance_line)","category":"page"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"Run a day-ahead simulation for a hybrid AC-DC power system with renewable generation and energy storage.","category":"page"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"Arguments:","category":"page"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"old_jpc: Original power system data structure\nopt: Power flow options\nday_load_matrix: Matrix containing hourly load data (hour, busid, activepower, reactive_power)\nday_price_line: Vector containing hourly electricity prices\nday_irradiance_line: Matrix containing hourly solar irradiance data","category":"page"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"Returns:","category":"page"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"Simulation results including bus voltages, branch flows, and economic data","category":"page"},{"location":"modules/timedomainpowerflow/#Run-Dynamic-Dispatch","page":"TimeDomainPowerFlow","title":"Run Dynamic Dispatch","text":"","category":"section"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"run_dynamic_dispatch(new_jpc, Cld_ac, Cld_dc, loadAC_PD, loadAC_QD, loadDC_PD, genAC_PG,\n                    Cgen_ac, Cconv_ac, Cconv_dc, η_rec, η_inv, Cpv_ac, Cpv_dc,\n                    pv_ac_p_mw_ratio, pv_ac_p_mw, pv_max_p_mw, pv_max_p_mw_ratio,\n                    Cstorage_ac, ess_initial_soc, ess_max_soc, ess_min_soc,\n                    ess_charge_efficiency, ess_discharge_efficiency, ess_p_mw,\n                    ess_e_mwh, ess_max_p_mw, ess_min_p_mw, time_step_h, time_periods,\n                    price_line, irradiance_line, opt)","category":"page"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"Performs dynamic dispatch optimization for a hybrid AC-DC power system with renewable generation and energy storage.","category":"page"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"Arguments:","category":"page"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"Power system parameters (jpc, loads, generators)\nConverter parameters (efficiency, costs)\nPV parameters (capacity, ratios)\nStorage parameters (SOC limits, efficiency, capacity)\nTime parameters and price/irradiance data\nPower flow options","category":"page"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"Returns:","category":"page"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"Optimized dispatch results and power flow solutions","category":"page"},{"location":"modules/timedomainpowerflow/#Visualization-Functions","page":"TimeDomainPowerFlow","title":"Visualization Functions","text":"","category":"section"},{"location":"modules/timedomainpowerflow/#Plot-Voltage-Time-Series","page":"TimeDomainPowerFlow","title":"Plot Voltage Time Series","text":"","category":"section"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"plot_voltage_time_series(results, bus_name, case, time_day, bus_type = \"AC\"; \n                         save_path = nothing, save_format = \"pdf\")","category":"page"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"Plot voltage time series for a specified bus in a power system.","category":"page"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"Arguments:","category":"page"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"results: Simulation results containing bus voltage data\nbus_name: Name of the bus to plot voltage for\ncase: Power system case data\ntime_day: Number of days in the simulation\nbus_type: Type of bus to analyze (\"AC\" or \"DC\")\nsave_path: Optional path to save the plot\nsave_format: Format to save the plot","category":"page"},{"location":"modules/timedomainpowerflow/#Plot-Power-Flow-Violations","page":"TimeDomainPowerFlow","title":"Plot Power Flow Violations","text":"","category":"section"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"plot_flow_violations(results, case, time_day, flow_limit = 3.0, plot_type = \"summary\", \n                    flow_direction = \"max\"; save_path = nothing, save_format = \"pdf\")","category":"page"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"Plot power flow violations in power system branches.","category":"page"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"Arguments:","category":"page"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"results: Simulation results containing branch flow data\ncase: Power system case data\ntime_day: Number of days in the simulation\nflow_limit: Power flow limit in MW (default: 3.0)\nplot_type: Type of plot to generate:\n\"summary\": Overall statistics of violations\n\"worst\": Shows the worst branches with violations\n\"all\": Shows all branches with violations\nflow_direction: How to evaluate flow violations:\n\"max\": Maximum absolute value of flow in either direction\n\"both\": Same as \"max\"\n\"forward\": Only check flow from from-bus to to-bus\n\"reverse\": Only check flow from to-bus to from-bus\nsave_path: Optional path to save the plot\nsave_format: Format to save the plot","category":"page"},{"location":"modules/timedomainpowerflow/#Plot-Losses-Time-Series","page":"TimeDomainPowerFlow","title":"Plot Losses Time Series","text":"","category":"section"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"plot_losses_time_series(results, case, time_day, plot_type = \"total\", loss_type = \"active\"; \n                        save_path = nothing, save_format = \"pdf\")","category":"page"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"Plot power system losses time series for AC and DC branches.","category":"page"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"Arguments:","category":"page"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"results: Simulation results containing branch flow data\ncase: Power system case data\ntime_day: Number of days in the simulation\nplot_type: Type of plot to generate:\n\"total\": Overall system losses\n\"branch\": Individual branch losses for major branches\nloss_type: Type of losses to display:\n\"active\": Only active power losses (MW)\nsave_path: Optional path to save the plot\nsave_format: Format to save the plot","category":"page"},{"location":"modules/timedomainpowerflow/#Plot-Active-Load-Time-Series","page":"TimeDomainPowerFlow","title":"Plot Active Load Time Series","text":"","category":"section"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"plot_PD_time_series(results, bus_name, case, time_day; \n                   save_path = nothing, save_format = \"pdf\")","category":"page"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"Plot the time series of active load.","category":"page"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"Arguments:","category":"page"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"results: Result dataset\nbus_name: Bus name\ncase: Power system case data\ntime_day: Number of days in the simulation\nsave_path: Optional path to save the plot\nsave_format: Format to save the plot","category":"page"},{"location":"modules/timedomainpowerflow/#Record-Voltage-Violations","page":"TimeDomainPowerFlow","title":"Record Voltage Violations","text":"","category":"section"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"record_voltage_violation(results, bus_name, case, time_day, bus_type = \"AC\"; \n                        save_path = nothing, save_format = \"pdf\")","category":"page"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"Analyze and visualize voltage violations for a specified bus in a power system.","category":"page"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"Arguments:","category":"page"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"results: Simulation results containing bus voltage data\nbus_name: Name of the bus to analyze voltage violations for\ncase: Power system case data\ntime_day: Number of days in the simulation\nbus_type: Type of bus to analyze:\n\"AC\": AC bus\n\"DC\": DC bus\nsave_path: Optional path to save the plot\nsave_format: Format to save the plot","category":"page"},{"location":"modules/timedomainpowerflow/#Utility-Functions","page":"TimeDomainPowerFlow","title":"Utility Functions","text":"","category":"section"},{"location":"modules/timedomainpowerflow/#Renumber-Hybrid-System","page":"TimeDomainPowerFlow","title":"Renumber Hybrid System","text":"","category":"section"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"renumber_hybrid_system(jpc)","category":"page"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"Renumber buses and branches in a hybrid AC-DC power system to create a more organized numbering scheme.","category":"page"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"Arguments:","category":"page"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"jpc: A structure containing the hybrid power system data with fields:\nbusAC: Matrix of AC bus data\nbusDC: Matrix of DC bus data\nbranchAC: Matrix of AC branch data\nbranchDC: Matrix of DC branch data\nconvAC: Matrix of AC converter data\nconvDC: Matrix of DC converter data","category":"page"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"Returns:","category":"page"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"Updated jpc with renumbered components","category":"page"},{"location":"modules/timedomainpowerflow/#Testing","page":"TimeDomainPowerFlow","title":"Testing","text":"","category":"section"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"The module includes a test script (test_time_domain_pf.jl) that demonstrates the use of the TimeDomainPowerFlow module for analyzing a power system over a time period. The script:","category":"page"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"Loads required packages\nReads power system data\nConfigures simulation parameters\nRuns time-domain power flow analysis\nGenerates visualization of results","category":"page"},{"location":"modules/timedomainpowerflow/","page":"TimeDomainPowerFlow","title":"TimeDomainPowerFlow","text":"using Dates\nusing XLSX\nusing DataFrames\nusing Base.Filesystem\nusing HyDistFlow.TimeDomainPowerFlowlow\n\n# Input Data\nfile_path = joinpath(pwd(), \"data\", \"test_case.xlsx\")\nload_path = joinpath(pwd(), \"data\", \"load.xlsx\")  \nprice_path = joinpath(pwd(), \"data\", \"price.xlsx\")  \nirradiance_path = joinpath(pwd(), \"data\", \"irradiance.xlsx\")  \n\n# Process Data\ncase = load_julia_power_data(file_path)\ntime_column, time_str_column, load_names, data = read_load_data(load_path) \ntime_column, time_str_column, price_profiles = read_price_data(price_path)  \ntime_column, time_str_column, irradiance_profiles = read_irradiance_data(irradiance_path) \n\n# Topology processing\nresults, new_case = topology_analysis(case, output_file=\"topology_results.xlsx\")\n\n# Clear existing storage data and add a new battery storage system\nempty!(new_case.storageetap)\npush!(new_case.storages, Storage(1, \"Battery_ESS_1\", 3, 0.75, 1.5, 0.3, 0.05, 0.95, 0.9, true, \"lithium_ion\", true))\n\n# Set control mode for converters to Droop_Udc_Us (voltage droop control)\nnew_case.converters[3].control_mode = \"Droop_Udc_Us\"\nnew_case.converters[2].control_mode = \"Droop_Udc_Us\"\nnew_case.converters[1].control_mode = \"Droop_Udc_Us\"\n\nopt = options() # The initial settings \nopt[\"PF\"][\"NR_ALG\"] = \"bicgstab\";\nopt[\"PF\"][\"ENFORCE_Q_LIMS\"] = 0;\nopt[\"PF\"][\"DC_PREPROCESS\"] = 1;\n\n# Run time-series power flow calculation and measure execution time\n@time results = runtdpf(new_case, data, load_names, price_profiles, irradiance_profiles, opt)\n\n# # Get voltage results for all nodes\nplot_result = plot_voltage_time_series(results, \"Bus_21\", new_case, 366, \"AC\"; save_path=\"voltage_plot\")","category":"page"},{"location":"api/timedomainpowerflow/#API-Reference","page":"TimeDomainPowerFlow API","title":"API Reference","text":"","category":"section"},{"location":"api/timedomainpowerflow/#Input-Interface","page":"TimeDomainPowerFlow API","title":"Input Interface","text":"","category":"section"},{"location":"api/timedomainpowerflow/#HyDistFlow.TimeDomainPowerFlow.read_irradiance_data-Tuple{Any}","page":"TimeDomainPowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.read_irradiance_data","text":"read_irradiance_data(file_path)\n\nRead solar irradiance time series data from an Excel file.\n\nArguments\n\nfile_path: Path to the Excel file containing irradiance data\n\nReturns\n\nhour_column: Vector containing hour values from the first column\ntime_str_column: Vector containing time string representations from the second column\ndata: DataFrame containing the entire irradiance dataset\n\nDescription\n\nThis function reads solar irradiance time series data from an Excel file into a DataFrame. It extracts the hour values (first column) and time string representations (second column). The function returns these components separately along with the complete DataFrame for further processing.\n\n\n\n\n\n","category":"method"},{"location":"api/timedomainpowerflow/#HyDistFlow.TimeDomainPowerFlow.read_load_data-Tuple{Any}","page":"TimeDomainPowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.read_load_data","text":"read_load_data(file_path)\n\nRead load time series data from an Excel file.\n\nArguments\n\nfile_path: Path to the Excel file containing load data\n\nReturns\n\ntime_column: Vector containing time values from the first column\ntime_str_column: Vector containing time string representations from the second column\nload_names: Vector of load names extracted from column headers\ndata: DataFrame containing the entire load dataset\n\nDescription\n\nThis function reads load time series data from an Excel file into a DataFrame. It extracts the time values (first column), time string representations (second column), and the names of the loads from the column headers. The function returns these components separately along with the complete DataFrame for further processing.\n\n\n\n\n\n","category":"method"},{"location":"api/timedomainpowerflow/#HyDistFlow.TimeDomainPowerFlow.read_price_data-Tuple{Any}","page":"TimeDomainPowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.read_price_data","text":"read_price_data(file_path)\n\nRead electricity price time series data from an Excel file.\n\nArguments\n\nfile_path: Path to the Excel file containing price data\n\nReturns\n\ntime_column: Vector containing time values from the first column\ntime_str_column: Vector containing time string representations from the second column\ndata: DataFrame containing the entire price dataset\n\nDescription\n\nThis function reads electricity price time series data from an Excel file into a DataFrame. It extracts the time values (first column) and time string representations (second column). The function returns these components separately along with the complete DataFrame for further processing.\n\n\n\n\n\n","category":"method"},{"location":"api/timedomainpowerflow/#TimeSeries-Functions","page":"TimeDomainPowerFlow API","title":"TimeSeries Functions","text":"","category":"section"},{"location":"api/timedomainpowerflow/#HyDistFlow.TimeDomainPowerFlow.runtdpf-NTuple{6, Any}","page":"TimeDomainPowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.runtdpf","text":"runtdpf(case, data, load_names, price_profiles, irradiance_profiles, opt)\n\nRun time-domain power flow analysis for multiple days with varying loads, prices, and solar irradiance.\n\nArguments\n\ncase: Power system case data structure\ndata: DataFrame containing load time series data\nload_names: Vector of load names\nprice_profiles: Matrix containing electricity price data\nirradiance_profiles: Matrix containing solar irradiance data\nopt: Options for power flow calculation\n\nReturns\n\n3D array of results where dimensions represent [island, day, hour]\n\nDescription\n\nThis function performs time-domain power flow analysis across multiple days, considering varying loads, electricity prices, and solar irradiance. It processes the data day by day and handles multiple grid islands.\n\nThe function performs the following steps:\n\nDetermines the number of days from the time series data\nValidates that the number of time points is divisible by 24 (hours per day)\nGenerates daily load, price, and irradiance data using helper functions\nConverts the power system case to JPC format\nExtracts grid islands from the power system\nFor each day and each island (in parallel):\nExtracts the relevant load data for the island\nPerforms power flow calculations for each hour using the run_single_day function\nReturns a 3D array of results organized by island, day, and hour\n\nThe parallel processing is implemented using Julia's threading capabilities (@threads), with the outer loop over days being parallelized for efficiency.\n\n\n\n\n\n","category":"method"},{"location":"api/timedomainpowerflow/#HyDistFlow.TimeDomainPowerFlow.build_incidence_matrix_td-NTuple{4, Any}","page":"TimeDomainPowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.build_incidence_matrix_td","text":"build_incidence_matrix_td(n_nodes, branchAC, branchDC, converter)\n\nBuild the incidence matrix for a hybrid AC-DC power system.\n\nArguments\n\nn_nodes: Total number of nodes in the system\nbranchAC: Matrix containing AC branch data, with columns for from/to buses\nbranchDC: Matrix containing DC branch data, with columns for from/to buses\nconverter: Matrix containing converter data, with columns for AC/DC bus connections\n\nReturns\n\nA: Incidence matrix where rows represent branches and columns represent nodes\nbranch_data: Vector of tuples containing (fromnode, tonode, branchtype, originalindex) where branch_type is 1 for AC branches, 2 for DC branches, and 3 for converters\n\nDescription\n\nThis function constructs the node-branch incidence matrix for a hybrid AC-DC power system. The incidence matrix A has dimensions (nbranches × nnodes) where nbranches is the total number of branches (AC branches + DC branches + converters) and nnodes is the total number of nodes in the system.\n\nFor each branch connecting nodes i and j:\n\nA[branch, i] = 1 (outflow from node i is positive)\nA[branch, j] = -1 (inflow to node j is negative)\n\nThe function also returns branch_data, which provides information about each branch including its start and end nodes, type (AC, DC, or converter), and its original index in the input data. Branches are sorted by their starting node for consistent ordering.\n\n\n\n\n\n","category":"method"},{"location":"api/timedomainpowerflow/#Visualization","page":"TimeDomainPowerFlow API","title":"Visualization","text":"","category":"section"},{"location":"api/timedomainpowerflow/#HyDistFlow.TimeDomainPowerFlow.plot_flow_violations","page":"TimeDomainPowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.plot_flow_violations","text":"plot_flow_violations(results, case, time_day, flow_limit = 3.0, plot_type = \"summary\", flow_direction = \"max\"; save_path = nothing, save_format = \"pdf\")\n\nPlot power flow violations in power system branches.\n\nArguments\n\nresults: Simulation results containing branch flow data\ncase: Power system case data\ntime_day: Number of days in the simulation\nflow_limit: Power flow limit in MW (default: 3.0)\nplot_type: Type of plot to generate:\n\"summary\": Overall statistics of violations\n\"worst\": Shows the worst branches with violations\n\"all\": Shows all branches with violations\nflow_direction: How to evaluate flow violations:\n\"max\": Maximum absolute value of flow in either direction\n\"both\": Same as \"max\"\n\"forward\": Only check flow from from-bus to to-bus\n\"reverse\": Only check flow from to-bus to from-bus\nsave_path: Optional path to save the plot\nsave_format: Format to save the plot (default: \"pdf\")\n\nReturns\n\nplot_result: The generated plot\nviolation_count: Number of branches with violations at each time point\nmax_violation_percent: Maximum violation percentage at each time point\ntotal_violation_severity: Sum of violation severity at each time point\nviolation_details: Detailed information about each violation\nbranch_violation_stats: Statistics for each branch with violations\n\n\n\n\n\n","category":"function"},{"location":"api/timedomainpowerflow/#HyDistFlow.TimeDomainPowerFlow.plot_PD_time_series","page":"TimeDomainPowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.plot_PD_time_series","text":"Plot the time series of active load Parameters: results - Result dataset busname - Bus name case - System case timeday - Number of days bus_type - Bus type (default is \"AC\")\n\n\n\n\n\n","category":"function"},{"location":"api/timedomainpowerflow/#Other-Functions","page":"TimeDomainPowerFlow API","title":"Other Functions","text":"","category":"section"},{"location":"api/timedomainpowerflow/#HyDistFlow.TimeDomainPowerFlow.create_time_series_irradiance","page":"TimeDomainPowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.create_time_series_irradiance","text":"create_time_series_irradiance(irradiance_profiles, num_days=nothing)\n\nCreate time series solar irradiance data for renewable energy simulation.\n\nArguments\n\nirradiance_profiles: Matrix containing solar irradiance data, where rows represent days and columns represent hours\nnum_days: Optional parameter specifying the number of days to process (defaults to all available days)\n\nReturns\n\nDictionary mapping day number to irradiance matrix for that day\n\nDescription\n\nThis function processes solar irradiance profiles and organizes them into daily irradiance matrices. For each day, it creates a matrix where each row represents a specific hour, with columns: [hour, irradiance]\n\nThe function performs the following steps:\n\nDetermines the total number of days available in the irradiance profiles\nLimits processing to the specified number of days if provided\nFor each day and hour:\nExtracts the irradiance value from the irradiance profiles\nCreates a matrix with hour and irradiance information\nReturns a dictionary where keys are day numbers and values are the corresponding irradiance matrices\n\nThe irradiance profiles are expected to have a structure where the first column contains date information and subsequent columns (2-25) contain hourly irradiance data.\n\n\n\n\n\n","category":"function"},{"location":"api/timedomainpowerflow/#HyDistFlow.TimeDomainPowerFlow.create_time_series_loads-Tuple{JuliaPowerCase, Any, Any, Any}","page":"TimeDomainPowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.create_time_series_loads","text":"create_time_series_loads(case::Utils.JuliaPowerCase, data, load_names, num_days)\n\nCreate time series load data for power system simulation based on input data.\n\nArguments\n\ncase: Power system case data structure\ndata: DataFrame containing load time series data\nload_names: Vector of load names\nnum_days: Number of days to process\n\nReturns\n\nDictionary mapping day number to load matrix for that day\n\nDescription\n\nThis function processes time series load data and creates daily load matrices for power system simulation. For each day, it creates a matrix where each row represents a specific bus at a specific hour, with columns: [hour, busid, activepower, reactivepower, constzpercent, constipercent, constp_percent]\n\nThe function performs the following steps:\n\nValidates that the number of time points is divisible by 24 (hours per day)\nFilters in-service loads from the power system case\nMaps load names to column indices in the input data\nFor each day and hour:\nAccumulates loads connected to the same bus\nCalculates actual active and reactive power based on apparent power and power factor\nComputes weighted load characteristics (ZIP model parameters)\nEnsures load characteristic percentages sum to 1\nReturns a dictionary where keys are day numbers and values are the corresponding load matrices\n\nThe function handles cases where load names in the data match or don't match those in the power system case, maintaining power factor and appropriately scaling loads based on the input data.\n\n\n\n\n\n","category":"method"},{"location":"api/timedomainpowerflow/#HyDistFlow.TimeDomainPowerFlow.create_time_series_prices","page":"TimeDomainPowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.create_time_series_prices","text":"create_time_series_prices(price_profiles, num_days=nothing)\n\nCreate time series price data for power system economic analysis.\n\nArguments\n\nprice_profiles: Matrix containing electricity price data, where rows represent days and columns represent hours\nnum_days: Optional parameter specifying the number of days to process (defaults to all available days)\n\nReturns\n\nDictionary mapping day number to price matrix for that day\n\nDescription\n\nThis function processes electricity price profiles and organizes them into daily price matrices. For each day, it creates a matrix where each row represents a specific hour, with columns: [hour, price]\n\nThe function performs the following steps:\n\nDetermines the total number of days available in the price profiles\nLimits processing to the specified number of days if provided\nFor each day and hour:\nExtracts the price value from the price profiles\nCreates a matrix with hour and price information\nReturns a dictionary where keys are day numbers and values are the corresponding price matrices\n\nThe price profiles are expected to have a structure where the first column contains date information and subsequent columns (2-25) contain hourly price data.\n\n\n\n\n\n","category":"function"},{"location":"api/timedomainpowerflow/#HyDistFlow.TimeDomainPowerFlow.create_time_series_storage_profile","page":"TimeDomainPowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.create_time_series_storage_profile","text":"create_time_series_storage_profile(storage_profiles, num_days=nothing)\n\nCreate time series storage profile data for energy system simulation.\n\nArguments\n\nstorage_profiles: Matrix containing storage profile data, where rows represent days and columns represent hours\nnum_days: Optional parameter specifying the number of days to process (defaults to all available days)\n\nReturns\n\nDictionary mapping day number to storage profile matrix for that day\n\nDescription\n\nThis function processes storage profiles and organizes them into daily storage matrices. For each day, it creates a matrix where each row represents a specific hour, with columns: [hour, storage_value]\n\nThe function performs the following steps:\n\nDetermines the total number of days available in the storage profiles\nLimits processing to the specified number of days if provided\nFor each day and hour:\nExtracts the storage value from the storage profiles\nCreates a matrix with hour and storage value information\nReturns a dictionary where keys are day numbers and values are the corresponding storage profile matrices\n\nThe storage profiles are expected to have a structure where the first column contains date information and subsequent columns (2-25) contain hourly storage data.\n\n\n\n\n\n","category":"function"},{"location":"api/timedomainpowerflow/#HyDistFlow.TimeDomainPowerFlow.extract_load_matrix_by_islands-Tuple{Any, Any}","page":"TimeDomainPowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.extract_load_matrix_by_islands","text":"extract_load_matrix_by_islands(day_load_matrix, jpc_list)\n\nExtract and organize load data by power system islands.\n\nArguments\n\nday_load_matrix: Matrix containing load data for a day, where rows represent loads and columns include time, bus ID, and load values\njpc_list: List of power system cases representing different islands in the network\n\nReturns\n\nload_matrix_list: List of load matrices, one for each island\nisolated_load_matrix: Matrix containing load data for buses not belonging to any island\n\nDescription\n\nThis function distributes load data among different power system islands based on bus IDs. It separates the daily load data into distinct matrices for each island in the power system.\n\nThe function performs the following steps:\n\nExtracts bus IDs from the load data matrix (assumed to be in the second column)\nFor each island in the power system:\nIdentifies the AC buses belonging to the island\nFinds load data rows associated with those buses\nCreates a load matrix specific to that island\nIf no loads are found for an island, creates an empty matrix with the same column structure\nIdentifies loads on buses that don't belong to any valid island (isolated buses)\nReturns both the list of island-specific load matrices and the matrix for isolated loads\n\nThis function is essential for distributed power flow analysis where each island  needs to be processed separately with its corresponding load data.\n\n\n\n\n\n","category":"method"},{"location":"api/timedomainpowerflow/#HyDistFlow.TimeDomainPowerFlow.read_storage_profile_data-Tuple{Any}","page":"TimeDomainPowerFlow API","title":"HyDistFlow.TimeDomainPowerFlow.read_storage_profile_data","text":"read_storage_profile_data(file_path)\n\nRead storage profile time series data from an Excel file.\n\nArguments\n\nfile_path: Path to the Excel file containing storage profile data\n\nReturns\n\nhour_column: Vector containing hour values from the first column\ntime_str_column: Vector containing time string representations from the second column\ndata: DataFrame containing the entire storage profile dataset\n\nDescription\n\nThis function reads storage profile time series data from an Excel file into a DataFrame. It extracts the hour values (first column) and time string representations (second column). The function returns these components separately along with the complete DataFrame for further processing.\n\n\n\n\n\n","category":"method"},{"location":"#HyDistFlow.jl","page":"Home","title":"HyDistFlow.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Hybrid AC/DC Distribution System Analysis Tool","category":"page"},{"location":"","page":"Home","title":"Home","text":"HyDistFlow.jl is a Julia package developed by the HR-PES team of Xi'an Jiaotong University, which provides a static/dynamic power flow simulation framework for hybrid AC/DC distribution systems incorporating various renewable resources.","category":"page"},{"location":"#1.-Features","page":"Home","title":"1. Features","text":"","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Integration of PF and OPF: Using relaxed OPF to bridge time-varying loads and generation profiles with ESS status, integrating VSC power allocation into Power Flow calculations\nCustomizable Simulation Environment: Comprehensive parameter customization including irradiance data, electricity prices, load profiles, and flexible network topology configuration\nComprehensive Renewable Energy Models: Validated mathematical models for energy storage, photovoltaic generation, and VSCs for reliable distribution network analysis\nAdvanced VSC Control Framework: Implementation of seven control modes (voltage, reactive power, droop control, etc.) with corresponding solution algorithms\nFlexible Case Management: Support for both externally imported and internally generated case studies with complete data structures","category":"page"},{"location":"#Project-Structure","page":"Home","title":"Project Structure","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HyDistFlow.jl contains four main modules:","category":"page"},{"location":"","page":"Home","title":"Home","text":"ComponentModel: Power system component modeling\nUtils: General utility functions\nPowerFlow: AC/DC hybrid power flow calculation\nTimeDomainPowerFlow: Time series power flow analysis","category":"page"},{"location":"#2.-Installation","page":"Home","title":"2. Installation","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can install this package through Julia's package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"HyDistFlow\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Or, if you want to use the latest development version:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url=\"https://github.com/Luosipeng/HyDistFlow.jl.git\")","category":"page"},{"location":"#3.-Quick-Start-Example","page":"Home","title":"3. Quick Start Example","text":"","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here's a simple example showing how to use HyDistFlow.jl to run the time series power flow:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Add project path\npush!(LOAD_PATH, \"/path/to/HyDistFlow\")\n\n# Import modules\nusing Dates\nusing XLSX\nusing DataFrames\nusing Base.Threads\nusing HyDistFlow\n\n# Input Data\nfile_path = joinpath(pwd(), \"data\", \"test_case.xlsx\")\nload_path = joinpath(pwd(), \"data\", \"load.xlsx\")  \nprice_path = joinpath(pwd(), \"data\", \"price.xlsx\")  \nirradiance_path = joinpath(pwd(), \"data\", \"irradiance.xlsx\")  \n\n# Process Data\ncase = load_julia_power_data(file_path)\ntime_column, time_str_column, load_names, data = read_load_data(load_path) \ntime_column, time_str_column, price_profiles = read_price_data(price_path)  \ntime_column, time_str_column, irradiance_profiles = read_irradiance_data(irradiance_path) \n\n# Topology processing\nresults, new_case = topology_analysis(case, output_file=\"topology_results.xlsx\")\n\n# Clear existing storage data and add a new battery storage system\nempty!(new_case.storageetap)\npush!(new_case.storages, Storage(1, \"Battery_ESS_1\", 3, 0.75, 1.5, 0.3, 0.05, 0.95, 0.9, true, \"lithium_ion\", true))\n\n# Set control mode for converters to Droop_Udc_Us (voltage droop control)\nnew_case.converters[3].control_mode = \"Droop_Udc_Us\"\nnew_case.converters[2].control_mode = \"Droop_Udc_Us\"\nnew_case.converters[1].control_mode = \"Droop_Udc_Us\"\n\nopt = options() # The initial settings \nopt[\"PF\"][\"NR_ALG\"] = \"bicgstab\";\nopt[\"PF\"][\"ENFORCE_Q_LIMS\"] = 0;\nopt[\"PF\"][\"DC_PREPROCESS\"] = 1;\n\n# Run time-series power flow calculation and measure execution time\n@time results = runtdpf(new_case, data, load_names, price_profiles, irradiance_profiles, opt)\n\n# # Get voltage results for all nodes\nplot_result = plot_voltage_time_series(results, \"Bus_21\", new_case, 366, \"AC\"; save_path=\"voltage_plot\")","category":"page"},{"location":"#4.-Documentation-Structure","page":"Home","title":"4. Documentation Structure","text":"","category":"section"},{"location":"#Documentation-Structure","page":"Home","title":"Documentation Structure","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This documentation is divided into the following sections:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Module: Detailed usage and examples of various modules\nComponentModel: Detailed introduction to ComponentModel.jl\nUtils: Detailed introduction to Utils.jl\nPowerFlow: Detailed introduction to PowerFlow.jl\nTimeDomainPowerFlow: Detailed introduction to TimeDomainPowerFlow.jl\nAPI: API document of various modules\nComponentModel API: API document of ComponentModel.jl\nUtils API: API document of Utils.jl\nPowerFlow API: API document of PowerFlow.jl\nTimeDomainPowerFlow API: API document of TimeDomainPowerFlow.jl\nReferences: Citation information for HyDistFlow.jl and acknowledgments of referenced works and dependencies","category":"page"},{"location":"#5.-Contribution-and-License-Information","page":"Home","title":"5. Contribution and License Information","text":"","category":"section"},{"location":"#Contribution","page":"Home","title":"Contribution","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Contributions to HyDistFlow.jl are welcome! Please refer to the Contribution Guidelines for more information.","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HyDistFlow.jl is licensed under the MIT License.","category":"page"},{"location":"#6.-Citation-Information","page":"Home","title":"6. Citation Information","text":"","category":"section"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use HyDistFlow.jl in your research, please cite:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@software{HyDistFlow2025,\n  author = {Sipeng Luo,Tianyang Zhao,Zhaohong Bie},\n  title = {HyDistFlow.jl: a Julia package for time series power flow analysis},\n  year = {2025},\n  url = {https://github.com/Luosipeng/HyDistFlow.jl}\n}","category":"page"}]
}

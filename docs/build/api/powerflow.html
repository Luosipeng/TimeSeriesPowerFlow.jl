<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>PowerFlow API · HyDistFlow.jl</title><meta name="title" content="PowerFlow API · HyDistFlow.jl"/><meta property="og:title" content="PowerFlow API · HyDistFlow.jl"/><meta property="twitter:title" content="PowerFlow API · HyDistFlow.jl"/><meta name="description" content="Documentation for HyDistFlow.jl."/><meta property="og:description" content="Documentation for HyDistFlow.jl."/><meta property="twitter:description" content="Documentation for HyDistFlow.jl."/><meta property="og:url" content="https://Luosipeng.github.io/HyDistFlow.jl/api\\powerflow.html"/><meta property="twitter:url" content="https://Luosipeng.github.io/HyDistFlow.jl/api\\powerflow.html"/><link rel="canonical" href="https://Luosipeng.github.io/HyDistFlow.jl/api\\powerflow.html"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><span class="tocitem">Module</span><ul><li><a class="tocitem" href="../modules/overview.html">Overview</a></li><li><a class="tocitem" href="../modules/componentmodel.html">ComponentModel</a></li><li><a class="tocitem" href="../modules/utils.html">Utils</a></li><li><a class="tocitem" href="../modules/powerflow.html">PowerFlow</a></li><li><a class="tocitem" href="../modules/timedomainpowerflow.html">TimeDomainPowerFlow</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="componentmodel.html">ComponentModel API</a></li><li><a class="tocitem" href="utils.html">Utils API</a></li><li class="is-active"><a class="tocitem" href="powerflow.html">PowerFlow API</a><ul class="internal"><li><a class="tocitem" href="#Power-Flow-Algorithm"><span>Power Flow Algorithm</span></a></li><li><a class="tocitem" href="#DC-Power-Flow-Algorithm"><span>DC Power Flow Algorithm</span></a></li><li><a class="tocitem" href="#Linear-Problem-Solution-Algorithm"><span>Linear Problem Solution Algorithm</span></a></li><li><a class="tocitem" href="#GPU-Acceleration"><span>GPU Acceleration</span></a></li><li><a class="tocitem" href="#Other-Functions"><span>Other Functions</span></a></li></ul></li><li><a class="tocitem" href="timedomainpowerflow.html">TimeDomainPowerFlow API</a></li><li><a class="tocitem" href="hydistflow.html">HyDistFlow API</a></li></ul></li><li><a class="tocitem" href="../references.html">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href="powerflow.html">PowerFlow API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="powerflow.html">PowerFlow API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Luosipeng/HyDistFlow.jl.git" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="github.com/Luosipeng/HyDistFlow.jl/blob/master/docs/src/api/powerflow.md#L" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><h2 id="Power-Flow-Algorithm"><a class="docs-heading-anchor" href="#Power-Flow-Algorithm">Power Flow Algorithm</a><a id="Power-Flow-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Flow-Algorithm" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.adaptive_damped_newton" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.adaptive_damped_newton"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.adaptive_damped_newton</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">adaptive_damped_newton(baseMVA, bus, gen, load, pvarray, Ybus, V0, ref, p, tol0, max_it0, alg=&quot;&quot;)</code></pre><p>Solve power flow using an adaptive damped Newton-Raphson method.</p><p>This function implements a Newton-Raphson method with adaptive damping factor to improve convergence in difficult cases. The damping factor is automatically adjusted based on the mismatch norm during iterations.</p><p><strong>Arguments</strong></p><ul><li><code>baseMVA</code>: Base MVA for the system</li><li><code>bus</code>: Bus data matrix</li><li><code>gen</code>: Generator data matrix</li><li><code>load</code>: Load data matrix</li><li><code>pvarray</code>: PV array data</li><li><code>Ybus</code>: Bus admittance matrix</li><li><code>V0</code>: Initial voltage vector</li><li><code>ref</code>: Reference bus index</li><li><code>p</code>: Vector of bus indices</li><li><code>tol0</code>: Convergence tolerance</li><li><code>max_it0</code>: Maximum number of iterations</li><li><code>alg</code>: Linear solver algorithm (optional)</li></ul><p><strong>Returns</strong></p><ul><li><code>V</code>: Final voltage solution vector</li><li><code>converged</code>: Boolean indicating convergence status</li><li><code>i</code>: Number of iterations performed</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/adaptive_damped_newton.jl#LL1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.currentinjectionpf" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.currentinjectionpf"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.currentinjectionpf</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">currentinjectionpf(baseMVA, bus, gen, load, pvarray, Ybus, V0, ref, p, tol0, max_it0, alg=&quot;&quot;)</code></pre><p>Solve power flow using the Current Injection method, particularly suitable for resistive networks.</p><p><strong>Arguments</strong></p><ul><li><code>baseMVA</code>: Base MVA for power system normalization</li><li><code>bus</code>: Matrix containing bus data</li><li><code>gen</code>: Matrix containing generator data</li><li><code>load</code>: Matrix containing load data</li><li><code>pvarray</code>: Array of PV bus information</li><li><code>Ybus</code>: Bus admittance matrix</li><li><code>V0</code>: Initial voltage vector</li><li><code>ref</code>: Reference (slack) bus index</li><li><code>p</code>: Array of PQ bus indices</li><li><code>tol0</code>: Convergence tolerance</li><li><code>max_it0</code>: Maximum number of iterations</li><li><code>alg</code>: Algorithm variant (optional)</li></ul><p><strong>Returns</strong></p><ul><li><code>V</code>: Final complex voltage vector solution</li><li><code>converged</code>: Boolean indicating whether the algorithm converged</li><li><code>i</code>: Number of iterations performed</li></ul><p><strong>Description</strong></p><p>This function implements the Current Injection power flow method, which is particularly effective for networks with high R/X ratios (resistive networks). The method works by:</p><ol><li>Converting power injections to current injections</li><li>Calculating current mismatches</li><li>Solving for voltage updates using the real part of the admittance matrix</li><li>Iterating until convergence or maximum iterations reached</li></ol></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/currentinjectionpf.jl#LL1-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.newtonpf" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.newtonpf"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.newtonpf</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">newtonpf(baseMVA::Float64, bus::Matrix{Float64}, gen::Matrix{Float64}, 
         Ybus::SparseArrays.SparseMatrixCSC{ComplexF64}, V0::Vector{ComplexF64}, 
         ref::Vector{Int}, pv::Vector{Int}, pq::Vector{Int}, 
         tol0::Float64, max_it0::Int, alg::String=&quot;bicgstab&quot;)</code></pre><p>Solve AC power flow using Newton-Raphson method.</p><p><strong>Arguments</strong></p><ul><li><code>baseMVA</code>: Base MVA for the system</li><li><code>bus</code>: Bus data matrix</li><li><code>gen</code>: Generator data matrix</li><li><code>Ybus</code>: Bus admittance matrix</li><li><code>V0</code>: Initial voltage vector</li><li><code>ref</code>: Reference bus indices</li><li><code>pv</code>: PV bus indices</li><li><code>pq</code>: PQ bus indices</li><li><code>tol0</code>: Convergence tolerance</li><li><code>max_it0</code>: Maximum number of iterations</li><li><code>alg</code>: Algorithm specification for linear solver (default: &quot;bicgstab&quot;)</li></ul><p><strong>Returns</strong></p><ul><li><code>V</code>: Final voltage vector solution</li><li><code>converged</code>: Boolean indicating whether the algorithm converged</li><li><code>i</code>: Number of iterations performed</li><li><code>norm_history</code>: Array of norm values for each iteration</li></ul><p><strong>Description</strong></p><p>This function implements the Newton-Raphson method to solve AC power flow equations. It iteratively updates voltage magnitudes and angles until the power mismatch falls below the specified tolerance or the maximum number of iterations is reached.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/newtonpf.jl#LL122-L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.newtonpf" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.newtonpf"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.newtonpf</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">newtonpf(baseMVA::Float64, bus::Matrix{Float64}, gen::Matrix{Float64}, 
    load::Matrix{Float64}, pvarray, Ybus::SparseArrays.SparseMatrixCSC{ComplexF64}, V0::Vector{ComplexF64}, 
    ref::Vector{Int}, pv::Vector{Int}, pq::Vector{Int}, 
    tol0::Float64, max_it0::Int, alg::String=&quot;bicgstab&quot;)</code></pre><p>Solve AC power flow using Newton-Raphson method with load and PV array models.</p><p><strong>Arguments</strong></p><ul><li><code>baseMVA</code>: Base MVA for the system</li><li><code>bus</code>: Bus data matrix</li><li><code>gen</code>: Generator data matrix</li><li><code>load</code>: Load data matrix</li><li><code>pvarray</code>: PV array data</li><li><code>Ybus</code>: Bus admittance matrix</li><li><code>V0</code>: Initial voltage vector</li><li><code>ref</code>: Reference bus indices</li><li><code>pv</code>: PV bus indices</li><li><code>pq</code>: PQ bus indices</li><li><code>tol0</code>: Convergence tolerance</li><li><code>max_it0</code>: Maximum number of iterations</li><li><code>alg</code>: Algorithm specification for linear solver (default: &quot;bicgstab&quot;)</li></ul><p><strong>Returns</strong></p><ul><li><code>V</code>: Final voltage vector solution</li><li><code>converged</code>: Boolean indicating whether the algorithm converged</li><li><code>i</code>: Number of iterations performed</li><li><code>norm_history</code>: Array of norm values for each iteration</li></ul><p><strong>Description</strong></p><p>This function implements the Newton-Raphson method to solve AC power flow equations with load and PV array models. It iteratively updates voltage magnitudes and angles until the power mismatch falls below the specified tolerance or the maximum number of iterations is reached.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/newtonpf.jl#LL1-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.newtonpf_gpu" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.newtonpf_gpu"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.newtonpf_gpu</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">newtonpf_gpu(baseMVA, bus, gen, load, Ybus, V0, ref, pv, pq, tol0, max_it0, alg=&quot;gpuLU&quot;)</code></pre><p>Solve AC power flow using Newton&#39;s method with GPU acceleration.</p><p><strong>Arguments</strong></p><ul><li><code>baseMVA</code>: Base MVA for the system</li><li><code>bus</code>: Bus data matrix</li><li><code>gen</code>: Generator data matrix</li><li><code>load</code>: Load data matrix</li><li><code>Ybus</code>: Bus admittance matrix</li><li><code>V0</code>: Initial voltage vector</li><li><code>ref</code>: Reference bus index</li><li><code>pv</code>: Vector of PV bus indices</li><li><code>pq</code>: Vector of PQ bus indices</li><li><code>tol0</code>: Convergence tolerance</li><li><code>max_it0</code>: Maximum number of iterations</li><li><code>alg</code>: Algorithm specification for linear solver (default: &quot;gpuLU&quot;)</li></ul><p><strong>Returns</strong></p><ul><li><code>V</code>: Final voltage vector solution</li><li><code>converged</code>: Boolean indicating whether the algorithm converged</li><li><code>i</code>: Number of iterations performed</li></ul><p><strong>Description</strong></p><p>This function implements the Newton-Raphson method to solve AC power flow equations using GPU acceleration. It iteratively updates voltage magnitudes and angles until the power mismatch falls below the specified tolerance or the maximum number of iterations is reached.</p><p>The algorithm:</p><ol><li>Initializes voltage values and transfers data to GPU</li><li>Calculates initial power mismatches</li><li>Constructs the Jacobian matrix for each iteration</li><li>Updates voltage values using Newton&#39;s method</li><li>Checks convergence based on power mismatch norm</li></ol><p><strong>Notes</strong></p><ul><li>This implementation uses GPU acceleration for improved performance</li><li>The Jacobian matrix is constructed in block form with partial derivatives</li><li>The function handles both real and reactive power balance constraints</li><li>Data is transferred between CPU and GPU as needed for computation</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/newtonpf_gpu.jl#LL1-L43">source</a></section></article><h2 id="DC-Power-Flow-Algorithm"><a class="docs-heading-anchor" href="#DC-Power-Flow-Algorithm">DC Power Flow Algorithm</a><a id="DC-Power-Flow-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#DC-Power-Flow-Algorithm" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.newtondcpf" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.newtondcpf"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.newtondcpf</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">newtondcpf(baseMVA, bus, gen, load, pvarray, Ybus, V0, ref, p, tol0, max_it0, alg=&quot;&quot;)</code></pre><p>Solve DC power flow using Newton&#39;s method.</p><p><strong>Arguments</strong></p><ul><li><code>baseMVA</code>: Base MVA for the system</li><li><code>bus</code>: Bus data matrix</li><li><code>gen</code>: Generator data matrix</li><li><code>load</code>: Load data matrix</li><li><code>pvarray</code>: PV array data</li><li><code>Ybus</code>: Bus admittance matrix</li><li><code>V0</code>: Initial voltage vector</li><li><code>ref</code>: Reference bus index</li><li><code>p</code>: Vector of indices for buses to be included in the calculation</li><li><code>tol0</code>: Convergence tolerance</li><li><code>max_it0</code>: Maximum number of iterations</li><li><code>alg</code>: Algorithm specification for linear solver (optional)</li></ul><p><strong>Returns</strong></p><ul><li><code>V</code>: Final voltage vector solution</li><li><code>converged</code>: Boolean indicating whether the algorithm converged</li><li><code>i</code>: Number of iterations performed</li></ul><p><strong>Description</strong></p><p>This function implements the Newton-Raphson method to solve DC power flow equations. It iteratively updates voltage values until the power mismatch falls below the specified tolerance or the maximum number of iterations is reached.</p><p>The algorithm:</p><ol><li>Initializes voltage values from the provided starting point</li><li>Calculates initial power mismatches</li><li>Constructs the Jacobian matrix for each iteration</li><li>Updates voltage values using Newton&#39;s method</li><li>Checks convergence based on power mismatch norm</li></ol><p><strong>Notes</strong></p><ul><li>The Jacobian matrix represents the partial derivatives of power with respect to voltage</li><li>This implementation handles both real power balance constraints</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/newtondcpf.jl#LL1-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.newtondcpf_sp" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.newtondcpf_sp"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.newtondcpf_sp</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">newtondcpf_sp(baseMVA, bus, gen, load, pvarray, Ybus, V0, ref, p, tol0, max_it0, alg=&quot;&quot;)</code></pre><p>Solve DC power flow using Newton&#39;s method with sparse matrices.</p><p><strong>Arguments</strong></p><ul><li><code>baseMVA</code>: Base MVA for the system</li><li><code>bus</code>: Bus data matrix</li><li><code>gen</code>: Generator data matrix</li><li><code>load</code>: Load data matrix</li><li><code>pvarray</code>: PV array data</li><li><code>Ybus</code>: Bus admittance matrix</li><li><code>V0</code>: Initial voltage vector</li><li><code>ref</code>: Reference bus index</li><li><code>p</code>: Vector of indices for buses to be included in the calculation</li><li><code>tol0</code>: Convergence tolerance</li><li><code>max_it0</code>: Maximum number of iterations</li><li><code>alg</code>: Algorithm specification (optional)</li></ul><p><strong>Returns</strong></p><ul><li><code>V</code>: Final voltage vector solution</li><li><code>converged</code>: Boolean indicating whether the algorithm converged</li><li><code>i</code>: Number of iterations performed</li></ul><p><strong>Description</strong></p><p>This function solves DC power flow using Newton&#39;s method. In DC systems,  power P = V * I, where I = G * V (G is the conductance matrix). The function  iteratively updates voltage magnitudes until the power mismatch falls below  the specified tolerance or the maximum number of iterations is reached.</p><p>The algorithm:</p><ol><li>Initializes voltage values from the provided starting point</li><li>Calculates initial power mismatches</li><li>Constructs the Jacobian matrix for each iteration</li><li>Updates voltage values using Newton&#39;s method</li><li>Checks convergence based on power mismatch norm</li></ol><p><strong>Notes</strong></p><ul><li>For DC systems, only active power is considered</li><li>The Jacobian matrix represents the partial derivatives of power with respect to voltage</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/newtondcpf_sp.jl#LL1-L41">source</a></section></article><h2 id="Linear-Problem-Solution-Algorithm"><a class="docs-heading-anchor" href="#Linear-Problem-Solution-Algorithm">Linear Problem Solution Algorithm</a><a id="Linear-Problem-Solution-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Problem-Solution-Algorithm" title="Permalink"></a></h2><h2 id="GPU-Acceleration"><a class="docs-heading-anchor" href="#GPU-Acceleration">GPU Acceleration</a><a id="GPU-Acceleration-1"></a><a class="docs-heading-anchor-permalink" href="#GPU-Acceleration" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.calculate_pv_power_gpu-NTuple{4, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.calculate_pv_power_gpu-NTuple{4, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.calculate_pv_power_gpu</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calculate_pv_power_gpu(pvarray_gpu, bus_gpu, Vm_gpu, baseMVA)</code></pre><p>Calculate power injections from PV arrays and their derivatives with respect to voltage magnitude using GPU acceleration.</p><p><strong>Arguments</strong></p><ul><li><code>pvarray_gpu</code>: PV array data matrix on GPU with columns representing PV parameters</li><li><code>bus_gpu</code>: Bus data matrix on GPU with columns representing bus parameters</li><li><code>Vm_gpu</code>: Vector of bus voltage magnitudes on GPU</li><li><code>baseMVA</code>: Base MVA for the system</li></ul><p><strong>Returns</strong></p><ul><li><code>Spv</code>: Vector of complex power injections from PV arrays</li><li><code>dSpv_dVm</code>: Sparse matrix of partial derivatives of PV power injections with respect to voltage magnitude</li></ul><p><strong>Description</strong></p><p>This function computes the power injections from PV arrays using a modified power function model that relates voltage to current output. It also calculates the derivatives of these injections with respect to voltage magnitude for use in power flow Jacobian calculations.</p><p>The function filters active PV arrays, maps them to their connected buses, and calculates their power output based on the current voltage conditions.</p><p><strong>Notes</strong></p><ul><li>Power output is calculated using a modified power function model with parameters a, b, and c</li><li>The model accounts for the nonlinear relationship between voltage and current in PV arrays</li><li>Results are converted to per-unit on system MVA base</li><li>Only real power is considered (no reactive power from PV arrays)</li><li>Calculations are partially performed on CPU for complex operations</li></ul><p><strong>Constants Used (assumed to be defined elsewhere)</strong></p><ul><li>PV<em>IN</em>SERVICE: Column index for PV array service status</li><li>BUS<em>I: Column index for bus number in bus</em>gpu matrix</li><li>PV<em>BUS: Column index for connected bus number in pvarray</em>gpu matrix</li><li>BASE<em>KV: Column index for base voltage in bus</em>gpu matrix</li><li>PV<em>VOC: Column index for open circuit voltage in pvarray</em>gpu matrix</li><li>PV<em>ISC: Column index for short circuit current in pvarray</em>gpu matrix</li><li>PV<em>AREA: Column index for PV array area in pvarray</em>gpu matrix</li><li>PV<em>VMPP: Column index for maximum power point voltage in pvarray</em>gpu matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/makeSbus_gpu.jl#LL115-L154">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.create_bus_mapping-Tuple{Any, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.create_bus_mapping-Tuple{Any, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.create_bus_mapping</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_bus_mapping(bus_gpu, BUS_I)</code></pre><p>Create a mapping dictionary from bus numbers to their indices in the bus matrix.</p><p><strong>Arguments</strong></p><ul><li><code>bus_gpu</code>: Bus data matrix on GPU with columns representing bus parameters</li><li><code>BUS_I</code>: Column index for bus number in bus_gpu matrix</li></ul><p><strong>Returns</strong></p><ul><li><code>bus_to_idx</code>: Dictionary mapping bus numbers to their indices in the bus matrix</li></ul><p><strong>Description</strong></p><p>This function creates a dictionary that maps bus identification numbers to their  corresponding indices in the bus matrix. This mapping is useful for quickly finding the position of a specific bus in the data structures.</p><p><strong>Notes</strong></p><ul><li>The function transfers bus data from GPU to CPU for processing</li><li>Bus numbers may not be sequential or start from 1, hence the need for this mapping</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/makeSbus_gpu.jl#LL291-L311">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.find_bus_indices-Tuple{Any, Any, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.find_bus_indices-Tuple{Any, Any, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.find_bus_indices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_bus_indices(bus_to_idx, active_pv, PV_BUS)</code></pre><p>Find the indices of buses to which PV arrays are connected.</p><p><strong>Arguments</strong></p><ul><li><code>bus_to_idx</code>: Dictionary mapping bus numbers to their indices in the bus matrix</li><li><code>active_pv</code>: PV array data matrix with columns representing PV parameters</li><li><code>PV_BUS</code>: Column index for connected bus number in active_pv matrix</li></ul><p><strong>Returns</strong></p><ul><li><code>valid_pv</code>: Boolean array indicating which PV arrays are connected to valid buses</li><li><code>bus_indices</code>: Array of bus indices corresponding to each valid PV array</li></ul><p><strong>Description</strong></p><p>This function identifies which buses in the system have PV arrays connected to them. It returns a boolean mask indicating which PV arrays are connected to valid buses, and an array of the corresponding bus indices for those valid connections.</p><p><strong>Notes</strong></p><ul><li>The function processes data entirely on CPU for better dictionary lookup performance</li><li>PV arrays connected to non-existent buses are marked as invalid</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/makeSbus_gpu.jl#LL326-L348">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.makeSbus_gpu-NTuple{7, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.makeSbus_gpu-NTuple{7, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.makeSbus_gpu</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">makeSbus_gpu(baseMVA, bus_gpu, gen_gpu, gen, Vm_gpu, load_gpu, pvarray_gpu; dc=false, Sg=nothing, return_derivative=false)</code></pre><p>Build the vector of complex bus power injections using GPU acceleration.</p><p><strong>Arguments</strong></p><ul><li><code>baseMVA</code>: Base MVA for the system</li><li><code>bus_gpu</code>: Bus data matrix on GPU with columns representing bus parameters</li><li><code>gen_gpu</code>: Generator data matrix on GPU with columns representing generator parameters</li><li><code>gen</code>: Generator data matrix on CPU with columns representing generator parameters</li><li><code>Vm_gpu</code>: Vector of bus voltage magnitudes on GPU</li><li><code>load_gpu</code>: Load data matrix on GPU with columns representing load parameters</li><li><code>pvarray_gpu</code>: PV array data matrix on GPU with columns representing PV parameters</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>dc</code>: Boolean indicating whether to use DC power flow assumptions (default: false)</li><li><code>Sg</code>: Optional pre-computed generator complex power injections (default: nothing)</li><li><code>return_derivative</code>: Boolean indicating whether to return derivative of Sbus with respect to Vm (default: false)</li></ul><p><strong>Returns</strong></p><ul><li>If <code>return_derivative=false</code>: Vector of complex bus power injections (Sbus)</li><li>If <code>return_derivative=true</code>: Sparse matrix of partial derivatives of power injections with respect to voltage magnitude (dSbus_dVm)</li></ul><p><strong>Description</strong></p><p>This function computes the vector of complex bus power injections (Sbus) for power flow analysis using GPU acceleration. It accounts for ZIP load models (constant power, constant current, and constant impedance components), generator injections, and PV array injections.</p><p>When <code>return_derivative=true</code>, it returns the partial derivatives of the power injections with respect to voltage magnitude, which is useful for power flow Jacobian calculations.</p><p><strong>Notes</strong></p><ul><li>All power values are converted to per-unit on system MVA base</li><li>The function handles ZIP load models with percentages specified in load_gpu</li><li>Generator status is considered when computing injections</li><li>When dc=true, voltage magnitudes are set to 1.0 p.u.</li><li>PV array injections are calculated separately and added to the total bus injections</li></ul><p><strong>Constants Used (assumed to be defined elsewhere)</strong></p><ul><li>LOAD<em>CND: Column index for load bus number in load</em>gpu matrix</li><li>LOADP<em>PERCENT: Column index for constant power percentage in load</em>gpu matrix</li><li>LOADI<em>PERCENT: Column index for constant current percentage in load</em>gpu matrix</li><li>LOADZ<em>PERCENT: Column index for constant impedance percentage in load</em>gpu matrix</li><li>GEN_STATUS: Column index for generator status in gen matrix</li><li>GEN_BUS: Column index for generator bus number in gen matrix</li><li>PG: Column index for real power output in gen_gpu matrix</li><li>QG: Column index for reactive power output in gen_gpu matrix</li><li>PV<em>IN</em>SERVICE: Column index for PV array service status in pvarray_gpu matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/makeSbus_gpu.jl#LL1-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.process_pv_connections-NTuple{4, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.process_pv_connections-NTuple{4, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.process_pv_connections</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">process_pv_connections(bus_gpu, active_pv, BUS_I, PV_BUS)</code></pre><p>Process the connections between PV arrays and buses in the power system.</p><p><strong>Arguments</strong></p><ul><li><code>bus_gpu</code>: Bus data matrix on GPU with columns representing bus parameters</li><li><code>active_pv</code>: PV array data matrix with columns representing PV parameters</li><li><code>BUS_I</code>: Column index for bus number in bus_gpu matrix</li><li><code>PV_BUS</code>: Column index for connected bus number in active_pv matrix</li></ul><p><strong>Returns</strong></p><ul><li><code>valid_pv</code>: Boolean array indicating which PV arrays are connected to valid buses</li><li><code>bus_indices</code>: Array of bus indices corresponding to each valid PV array</li></ul><p><strong>Description</strong></p><p>This function coordinates the process of mapping PV arrays to their connected buses in the power system. It creates a mapping from bus numbers to indices, then uses this mapping to identify which PV arrays are connected to valid buses in the system.</p><p><strong>Notes</strong></p><ul><li>This is a wrapper function that calls create<em>bus</em>mapping and find<em>bus</em>indices</li><li>The function handles the complete process of validating PV-to-bus connections</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/makeSbus_gpu.jl#LL370-L393">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.Sd_gpu" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Sd_gpu"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.Sd_gpu</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Sd_gpu</code></pre><p>A mutable structure to store ZIP load model components on GPU.</p><p><strong>Fields</strong></p><ul><li><code>z</code>: Complex vector on GPU representing constant impedance component of load</li><li><code>i</code>: Complex vector on GPU representing constant current component of load</li><li><code>p</code>: Complex vector on GPU representing constant power component of load</li></ul><p>This structure is used to store the components of the ZIP load model in GPU memory for efficient power flow calculations.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/makeSdzip_gpu.jl#LL1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.makeSdzip_gpu-NTuple{5, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.makeSdzip_gpu-NTuple{5, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.makeSdzip_gpu</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">makeSdzip_gpu(baseMVA, bus_gpu, pw_1, pw_2, pw_3)</code></pre><p>Create a ZIP load model structure on GPU from bus data and ZIP percentages.</p><p><strong>Arguments</strong></p><ul><li><code>baseMVA</code>: Base MVA for the system</li><li><code>bus_gpu</code>: Bus data matrix on GPU with columns representing bus parameters</li><li><code>pw_1</code>: Vector of constant power percentages for active power</li><li><code>pw_2</code>: Vector of constant current percentages for active power</li><li><code>pw_3</code>: Vector of constant impedance percentages for active power</li></ul><p><strong>Returns</strong></p><ul><li><code>sd</code>: An Sd_gpu structure containing the ZIP load model components</li></ul><p><strong>Description</strong></p><p>This function creates a ZIP (constant impedance, constant current, constant power) load model on the GPU for power flow calculations. It converts the load data from the bus matrix to per-unit values based on the system MVA base and the specified percentages for each component.</p><p>The function assumes that the same percentage distribution applies to both active and reactive power, so it uses the same percentages (pw<em>1, pw</em>2, pw_3) for both P and Q components.</p><p><strong>Notes</strong></p><ul><li>All power values are converted to per-unit on system MVA base</li><li>PD and QD columns in bus_gpu represent the total active and reactive power demand</li><li>pw<em>1, pw</em>2, pw_3 represent the percentages of constant power, constant current, and constant impedance components</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/makeSdzip_gpu.jl#LL20-L47">source</a></section></article><h2 id="Other-Functions"><a class="docs-heading-anchor" href="#Other-Functions">Other Functions</a><a id="Other-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Other-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.calculate_pv_power-NTuple{4, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.calculate_pv_power-NTuple{4, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.calculate_pv_power</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calculate_pv_power(pvarray, bus, Vm, baseMVA)</code></pre><p>Calculate power injection from PV arrays and its derivative with respect to voltage magnitude.</p><p><strong>Arguments</strong></p><ul><li><code>pvarray</code>: PV array data matrix with columns representing PV parameters</li><li><code>bus</code>: Bus data matrix with columns representing bus parameters</li><li><code>Vm</code>: Vector of bus voltage magnitudes</li><li><code>baseMVA</code>: Base MVA for the system</li></ul><p><strong>Returns</strong></p><ul><li><code>Spv</code>: Vector of complex power injections from PV arrays</li><li><code>dSpv_dVm</code>: Sparse matrix of partial derivatives of PV power injections with respect to voltage magnitude</li></ul><p><strong>Description</strong></p><p>This function calculates the power injection from PV arrays based on a modified power function model that accounts for the PV array characteristics including open circuit voltage, short circuit current, and maximum power point voltage. It also computes the derivatives of these injections with respect to bus voltage magnitudes, which are needed for power flow Jacobian calculations.</p><p>The PV model uses a modified power function with correction terms to better represent the current-voltage characteristics of PV panels: I = Isc * (1 - (V/Voc)^a)^b * (1 - c * ((V/Vmpp) - 1)^2)</p><p><strong>Notes</strong></p><ul><li>Only active PV arrays (PV<em>IN</em>SERVICE &gt; 0) are considered</li><li>The function maps PV arrays to their respective buses using the bus numbering</li><li>Power output is converted to per-unit on system MVA base</li><li>Only real power (no reactive power) is considered for PV arrays</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/makeSbus.jl#LL144-L174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.makeSbus" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.makeSbus"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.makeSbus</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">makeSbus(baseMVA, bus, gen, Vm, Sg=nothing, return_derivative=false)</code></pre><p>Build the vector of complex bus power injections (simplified version without PV arrays).</p><p><strong>Arguments</strong></p><ul><li><code>baseMVA</code>: Base MVA for the system</li><li><code>bus</code>: Bus data matrix with columns representing bus parameters</li><li><code>gen</code>: Generator data matrix with columns representing generator parameters</li><li><code>Vm</code>: Vector of bus voltage magnitudes</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>Sg</code>: Optional pre-computed generator complex power injections (default: nothing)</li><li><code>return_derivative</code>: Boolean indicating whether to return derivative of Sbus with respect to Vm (default: false)</li></ul><p><strong>Returns</strong></p><ul><li>If <code>return_derivative=false</code>: Vector of complex bus power injections (Sbus)</li><li>If <code>return_derivative=true</code>: Sparse matrix of partial derivatives of power injections with respect to voltage magnitude (dSbus_dVm)</li></ul><p><strong>Description</strong></p><p>This is a simplified version of the makeSbus function that does not include PV array contributions. It computes the vector of complex bus power injections (Sbus) for power flow analysis, accounting for ZIP load models and generator injections.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/makeSbus.jl#LL84-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.makeSbus-Tuple{Any, Any, Any, Any, Matrix{Float64}, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.makeSbus-Tuple{Any, Any, Any, Any, Matrix{Float64}, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.makeSbus</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">makeSbus(baseMVA, bus, gen, Vm, load::Matrix{Float64}, pvarray; dc=false, Sg=nothing, return_derivative=false)</code></pre><p>Build the vector of complex bus power injections, including PV array contributions.</p><p><strong>Arguments</strong></p><ul><li><code>baseMVA</code>: Base MVA for the system</li><li><code>bus</code>: Bus data matrix with columns representing bus parameters</li><li><code>gen</code>: Generator data matrix with columns representing generator parameters</li><li><code>Vm</code>: Vector of bus voltage magnitudes</li><li><code>load</code>: Load data matrix with columns representing load parameters</li><li><code>pvarray</code>: PV array data matrix with columns representing PV parameters</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>dc</code>: Boolean indicating whether to use DC power flow assumptions (default: false)</li><li><code>Sg</code>: Optional pre-computed generator complex power injections (default: nothing)</li><li><code>return_derivative</code>: Boolean indicating whether to return derivative of Sbus with respect to Vm (default: false)</li></ul><p><strong>Returns</strong></p><ul><li>If <code>return_derivative=false</code>: Vector of complex bus power injections (Sbus)</li><li>If <code>return_derivative=true</code>: Sparse matrix of partial derivatives of power injections with respect to voltage magnitude (dSbus_dVm)</li></ul><p><strong>Description</strong></p><p>This function computes the vector of complex bus power injections (Sbus) for power flow analysis. It accounts for ZIP load models, generator injections, and PV array contributions.</p><p>When <code>return_derivative=true</code>, it returns the partial derivatives of the power injections with respect to voltage magnitude, which is useful for power flow Jacobian calculations.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/makeSbus.jl#LL1-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.Sd" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.Sd"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.Sd</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Sd</code></pre><p>A mutable structure to store ZIP load model components.</p><p><strong>Fields</strong></p><ul><li><code>z</code>: Complex vector representing constant impedance component of load</li><li><code>i</code>: Complex vector representing constant current component of load</li><li><code>p</code>: Complex vector representing constant power component of load</li></ul><p>This structure is used to store the components of the ZIP load model for efficient power flow calculations.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/makeSdzip.jl#LL1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.makeSdzip-NTuple{5, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.makeSdzip-NTuple{5, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.makeSdzip</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">makeSdzip(baseMVA, bus, pw_1, pw_2, pw_3)</code></pre><p>Create a ZIP load model structure from bus data and specified ZIP percentages.</p><p><strong>Arguments</strong></p><ul><li><code>baseMVA</code>: Base MVA for the system</li><li><code>bus</code>: Bus data matrix with columns representing bus parameters</li><li><code>pw_1</code>: Vector of constant power percentages for active power</li><li><code>pw_2</code>: Vector of constant current percentages for active power</li><li><code>pw_3</code>: Vector of constant impedance percentages for active power</li></ul><p><strong>Returns</strong></p><ul><li><code>sd</code>: An Sd structure containing the ZIP load model components</li></ul><p><strong>Description</strong></p><p>This function creates a ZIP (constant impedance, constant current, constant power) load model for power flow calculations. It converts the load data from the bus matrix to per-unit values based on the system MVA base and the specified percentages for each component.</p><p>The function assumes that the same percentage distribution applies to both active and reactive power, so it uses the same percentages (pw<em>1, pw</em>2, pw_3) for both P and Q components.</p><p><strong>Notes</strong></p><ul><li>All power values are converted to per-unit on system MVA base</li><li>PD and QD columns in bus represent the total active and reactive power demand</li><li>pw<em>1, pw</em>2, pw_3 represent the percentages of constant power, constant current, and constant impedance components</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/makeSdzip.jl#LL20-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.makeSdzip-Tuple{Any, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.makeSdzip-Tuple{Any, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.makeSdzip</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">makeSdzip(baseMVA, bus)</code></pre><p>Create a ZIP load model structure from bus data with default constant power model.</p><p><strong>Arguments</strong></p><ul><li><code>baseMVA</code>: Base MVA for the system</li><li><code>bus</code>: Bus data matrix with columns representing bus parameters</li></ul><p><strong>Returns</strong></p><ul><li><code>sd</code>: An Sd structure containing the ZIP load model components</li></ul><p><strong>Description</strong></p><p>This is a simplified version of the makeSdzip function that assumes a constant power model (100% constant power, 0% constant current, 0% constant impedance).</p><p><strong>Notes</strong></p><ul><li>All power values are converted to per-unit on system MVA base</li><li>PD and QD columns in bus represent the total active and reactive power demand</li><li>By default, all load is modeled as constant power (P-Q) load</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/makeSdzip.jl#LL60-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.makeYbus-Tuple{Any, Any, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.makeYbus-Tuple{Any, Any, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.makeYbus</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">makeYbus(baseMVA, bus, branch)</code></pre><p>Build the bus admittance matrix and branch admittance matrices.</p><p><strong>Arguments</strong></p><ul><li><code>baseMVA</code>: Base MVA for the system</li><li><code>bus</code>: Bus data matrix with columns representing bus parameters</li><li><code>branch</code>: Branch data matrix with columns representing branch parameters</li></ul><p><strong>Returns</strong></p><ul><li><code>Ybus</code>: Bus admittance matrix</li><li><code>Yf</code>: Branch admittance matrix for &quot;from&quot; end of branches</li><li><code>Yt</code>: Branch admittance matrix for &quot;to&quot; end of branches</li></ul><p><strong>Description</strong></p><p>This function builds the bus admittance matrix (Ybus) and branch admittance matrices (Yf and Yt) for a given power system network. The admittance matrices are essential components for power flow and other power system analyses.</p><p>The function:</p><ol><li>Computes branch series admittances and line charging susceptances</li><li>Handles tap ratios and phase shifters</li><li>Incorporates bus shunt admittances</li><li>Builds connection matrices between branches and buses</li><li>Constructs the complete bus admittance matrix</li></ol><p><strong>Notes</strong></p><ul><li>All admittance values are in per-unit on system MVA base</li><li>Requires buses to be numbered consecutively (internal ordering)</li><li>Branch status values determine which branches are in service</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/makeYbus.jl#LL1-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.merge_results-Tuple{Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.merge_results-Tuple{Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.merge_results</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">merge_results(results)</code></pre><p>Merge power flow calculation results from multiple isolated islands.</p><p><strong>Arguments</strong></p><ul><li><code>results</code>: An array of JPC objects containing power flow results for different islands</li></ul><p><strong>Returns</strong></p><ul><li><code>merged_result</code>: A single JPC object containing the combined results</li><li><code>area</code>: The number of islands that were merged</li></ul><p><strong>Description</strong></p><p>This function combines power flow results from multiple isolated islands into a single comprehensive result. It merges all data matrices (buses, branches, generators, etc.) from the individual island results and sorts them by their ID numbers.</p><p>The function:</p><ol><li>Creates a new JPC object to hold the merged results</li><li>Combines basic result fields like success status and iteration counts</li><li>Merges all data matrices from the input results</li><li>Sorts the merged matrices by their first column (typically ID numbers)</li></ol><p><strong>Notes</strong></p><ul><li>Assumes all input results use the same base MVA</li><li>Success is determined by the logical AND of all individual results&#39; success flags</li><li>Iteration count is the maximum of all individual results&#39; iteration counts</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/merge_results.jl#LL1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.extract_bus_data-Tuple{JPC}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.extract_bus_data-Tuple{JPC}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.extract_bus_data</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Extract bus data from your data structure</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/pf_summary.jl#LL555-L557">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.generate_matpower_report" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.generate_matpower_report"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.generate_matpower_report</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Format power flow calculation results as MATPOWER-style report and save to a text file</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/pf_summary.jl#LL600-L602">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.write_branch_data-Tuple{IOStream, JPC}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.write_branch_data-Tuple{IOStream, JPC}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.write_branch_data</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Write branch data section</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/pf_summary.jl#LL448-L450">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.write_bus_data-Tuple{IOStream, JPC, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.write_bus_data-Tuple{IOStream, JPC, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.write_bus_data</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Write bus data section</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/pf_summary.jl#LL255-L257">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.write_system_summary-Tuple{IOStream, JPC, Any, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.write_system_summary-Tuple{IOStream, JPC, Any, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.write_system_summary</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Write system summary section</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/pf_summary.jl#LL1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.dcpfsoln-Tuple{Float64, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Vararg{Any, 6}}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.dcpfsoln-Tuple{Float64, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Vararg{Any, 6}}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.dcpfsoln</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dcpfsoln(baseMVA::Float64, bus0::Matrix{Float64}, gen0::Matrix{Float64}, 
         branch0::Matrix{Float64}, load0::Matrix{Float64}, Ybus, Yf, Yt, V, ref, p)</code></pre><p>Update power system state variables after a DC power flow solution.</p><p><strong>Arguments</strong></p><ul><li><code>baseMVA::Float64</code>: Base MVA value for the system</li><li><code>bus0::Matrix{Float64}</code>: Initial bus data matrix</li><li><code>gen0::Matrix{Float64}</code>: Initial generator data matrix</li><li><code>branch0::Matrix{Float64}</code>: Initial branch data matrix</li><li><code>load0::Matrix{Float64}</code>: Load data matrix</li><li><code>Ybus</code>: Bus admittance matrix</li><li><code>Yf</code>: From-bus branch admittance matrix</li><li><code>Yt</code>: To-bus branch admittance matrix</li><li><code>V</code>: Complex bus voltage vector solution</li><li><code>ref</code>: Reference (slack) bus indices</li><li><code>p</code>: P bus indices</li></ul><p><strong>Returns</strong></p><ul><li><code>bus</code>: Updated bus data matrix</li><li><code>gen</code>: Updated generator data matrix</li><li><code>branch</code>: Updated branch data matrix with power flows</li></ul><p><strong>Description</strong></p><p>This function updates the power system state variables after a DC power flow solution has been obtained. It performs the following operations:</p><ol><li>Updates bus voltage magnitudes</li><li>Updates generator reactive power (Qg) for generators at PV and slack buses<ul><li>Distributes reactive power proportionally among multiple generators at the same bus</li><li>Respects generator reactive power limits</li></ul></li><li>Updates active power (Pg) for generators at slack buses</li><li>Calculates branch power flows</li><li>Expands the branch matrix if needed to store power flow results</li></ol><p>The function handles special cases like multiple generators at the same bus and generators with identical reactive power limits.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/dcpfsoln.jl#LL1-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.pfsoln-Tuple{Float64, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Vararg{Any, 7}}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.pfsoln-Tuple{Float64, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Vararg{Any, 7}}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.pfsoln</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Update power flow solution with computed voltage values and calculate generator outputs and branch flows. For the version with load data as a separate parameter.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/pfsoln.jl#LL1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.pfsoln-Tuple{Float64, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Vararg{Any, 7}}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.pfsoln-Tuple{Float64, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Vararg{Any, 7}}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.pfsoln</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Update power flow solution with computed voltage values and calculate generator outputs and branch flows. Standard version without separate load data parameter.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/pfsoln.jl#LL121-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.process_result-Tuple{Any, Any, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.process_result-Tuple{Any, Any, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.process_result</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Process power flow calculation results and generate a report. This function merges results, extracts execution time, and creates a MATPOWER format report.</p><p>Parameters:</p><ul><li>results: Array containing calculation results and timing information</li><li>isolated: Information about isolated parts of the network</li><li>file_path: Path where the report will be saved</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/process_result.jl#LL1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.analyze_voltage_results-Tuple{NamedTuple, JuliaPowerCase, String}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.analyze_voltage_results-Tuple{NamedTuple, JuliaPowerCase, String}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.analyze_voltage_results</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">analyze_voltage_results(results::NamedTuple, case::JuliaPowerCase, reference_file::String;
                       tolerance_mag::Float64=1e-4, tolerance_ang::Float64=1e-3,
                       output_dir::String=&quot;./results&quot;, save_pdf::Bool=true)</code></pre><p>Analyze voltage differences between power flow calculation results and reference file, generate comparison reports and charts. Supports both original format and AC/DC mixed format. Parameters:</p><ul><li>results: NamedTuple containing results in JPC format (typically the return value of power flow calculation)</li><li>case: Original JuliaPowerCase object, used to get node names and ID mappings</li><li>reference_file: Path to Excel file containing reference voltage values</li><li>tolerance_mag: Tolerance for voltage magnitude comparison (default: 1e-4)</li><li>tolerance_ang: Tolerance for voltage angle comparison (default: 1e-3)</li><li>output_dir: Output directory (default: &quot;./results&quot;)</li><li>save_pdf: Whether to save plots in PDF format in addition to PNG (default: true)</li></ul><p>Returns:</p><ul><li>DataFrame or NamedTuple containing comparison results</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/result_compare_etap.jl#LL716-L734">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.compare_voltage_results-Tuple{NamedTuple, JuliaPowerCase, String}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.compare_voltage_results-Tuple{NamedTuple, JuliaPowerCase, String}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.compare_voltage_results</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compare_voltage_results(results::NamedTuple, case::JuliaPowerCase, reference_file::String; 
                       tolerance_mag::Float64=1e-4, tolerance_ang::Float64=1e-3)</code></pre><p>Compare power flow calculation results in JPC format with reference voltage values, using JuliaPowerCase for node mapping. Supports both original format and new format with mixed AC/DC data. Parameters:</p><ul><li>results: NamedTuple containing results in JPC format (typically the return value of power flow calculation)</li><li>case: Original JuliaPowerCase object, used to get node names and ID mappings</li><li>reference_file: Path to Excel file containing reference voltage values</li><li>tolerance_mag: Tolerance for voltage magnitude comparison (default: 1e-4)</li><li>tolerance_ang: Tolerance for voltage angle comparison (default: 1e-3)</li></ul><p>Returns:</p><ul><li>NamedTuple containing comparison results, including ac and dc DataFrames</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/result_compare_etap.jl#LL1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_bus_voltage_results-Tuple{NamedTuple, JuliaPowerCase}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_bus_voltage_results-Tuple{NamedTuple, JuliaPowerCase}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_bus_voltage_results</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_bus_voltage_results(results::NamedTuple, case::JuliaPowerCase)</code></pre><p>Extract bus voltage information from power flow calculation results in JPC format, and map to node names in JuliaPowerCase. Parameters:</p><ul><li>results: NamedTuple containing results in JPC format (typically the return value of power flow calculation)</li><li>case: Original JuliaPowerCase object, used to get node names and ID mappings</li></ul><p>Returns:</p><ul><li>DataFrame containing bus voltage results</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/result_compare_etap.jl#LL273-L283">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_bus_voltage_results_acdc-Tuple{NamedTuple, JuliaPowerCase}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_bus_voltage_results_acdc-Tuple{NamedTuple, JuliaPowerCase}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_bus_voltage_results_acdc</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_bus_voltage_results_acdc(results::NamedTuple, case::JuliaPowerCase)</code></pre><p>Extract both AC and DC bus voltage information from power flow calculation results in JPC format, and map to node names in JuliaPowerCase. Parameters:</p><ul><li>results: NamedTuple containing results in JPC format (typically the return value of power flow calculation)</li><li>case: Original JuliaPowerCase object, used to get node names and ID mappings</li></ul><p>Returns:</p><ul><li>NamedTuple containing AC and DC bus voltage results as two DataFrames: ac and dc</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/result_compare_etap.jl#LL330-L340">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.plot_voltage_comparison" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.plot_voltage_comparison"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.plot_voltage_comparison</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_voltage_comparison(comparison_results, output_file::String=&quot;voltage_comparison.png&quot;;
                       show_plot::Bool=true)</code></pre><p>Plot voltage magnitude and angle comparison curves between calculated and reference values. Supports both original format and AC/DC mixed format. Parameters:</p><ul><li>comparison_results: Can be a DataFrame or a NamedTuple containing ac and dc DataFrames</li><li>output<em>file: Path to save the chart file (default: &quot;voltage</em>comparison.png&quot;)</li><li>show_plot: Whether to display the chart (default: true)</li></ul><p>Returns:</p><ul><li>Generated chart object or NamedTuple containing chart objects</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/result_compare_etap.jl#LL573-L585">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.plot_voltage_errors" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.plot_voltage_errors"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.plot_voltage_errors</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_voltage_errors(comparison_results, output_file::String=&quot;voltage_errors.png&quot;;
                   show_plot::Bool=true)</code></pre><p>Plot voltage magnitude and angle error curves. Supports both original format and AC/DC mixed format. Parameters:</p><ul><li>comparison_results: Can be a DataFrame or a NamedTuple containing ac and dc DataFrames</li><li>output<em>file: Path to save the chart file (default: &quot;voltage</em>errors.png&quot;)</li><li>show_plot: Whether to display the chart (default: true)</li></ul><p>Returns:</p><ul><li>Generated chart object or NamedTuple containing chart objects</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/result_compare_etap.jl#LL436-L448">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.save_comparison_results-Tuple{Any, String}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.save_comparison_results-Tuple{Any, String}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.save_comparison_results</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">save_comparison_results(comparison_results, output_file::String)</code></pre><p>Save comparison results to an Excel file. Supports both original format and AC/DC mixed format. Parameters:</p><ul><li>comparison_results: Can be a DataFrame or a NamedTuple containing ac and dc DataFrames</li><li>output_file: Output file path</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/result_compare_etap.jl#LL229-L236">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.rundcpf-Tuple{Any, Dict{String}}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.rundcpf-Tuple{Any, Dict{String}}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.rundcpf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Main function to call the DC power flow function     Input: case file     Output: results of the power flow as a dictionary     Example:     bus, gen, branch = rundcpf(casefile)</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/rundcpf.jl#LL1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.calculate_droop_voltage" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.calculate_droop_voltage"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.calculate_droop_voltage</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calculate_droop_voltage(P_dc, k_p, U_dc_ref=1.0, U_dc_min=0.95, U_dc_max=1.05)</code></pre><p>Calculate DC voltage with droop control using the equation: U<em>dc = U</em>dc<em>ref - k</em>p * P_dc Limits the output voltage to be within specified minimum and maximum values.</p><p>Parameters:</p><ul><li>P_dc: DC power</li><li>k_p: Droop coefficient</li><li>U<em>dc</em>ref: Reference DC voltage (default: 1.0 p.u.)</li><li>U<em>dc</em>min: Minimum allowed DC voltage (default: 0.95 p.u.)</li><li>U<em>dc</em>max: Maximum allowed DC voltage (default: 1.05 p.u.)</li></ul><p>Returns:</p><ul><li>Limited DC voltage value</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runhpf.jl#LL570-L585">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.runhpf-Tuple{Any, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.runhpf-Tuple{Any, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.runhpf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">runhpf(jpc, opt)</code></pre><p>Run hybrid power flow calculation for integrated AC/DC systems. Iteratively solves AC and DC power flow while updating converter power exchanges. Supports different converter control modes.</p><p>Parameters:</p><ul><li>jpc: JPC object containing both AC and DC system data</li><li>opt: Options for power flow calculation</li></ul><p>Returns:</p><ul><li>Updated JPC object with power flow results</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runhpf.jl#LL1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.update_ac_load!-NTuple{4, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.update_ac_load!-NTuple{4, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.update_ac_load!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_ac_load!(result_jpc, jpc1, ac_bus_id, P_ac)</code></pre><p>Helper function to update AC side load with power from converter. Creates a new load if none exists at the specified bus.</p><p>Parameters:</p><ul><li>result_jpc: Main JPC object containing all system data</li><li>jpc1: JPC object for AC system</li><li>ac<em>bus</em>id: ID of the AC bus to update</li><li>P_ac: AC power to add to the load</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runhpf.jl#LL502-L513">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.update_dc_load!-NTuple{4, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.update_dc_load!-NTuple{4, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.update_dc_load!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_dc_load!(result_jpc, jpc2, dc_bus_id, P_dc)</code></pre><p>Helper function to update DC side load with power from converter. Creates a new load if none exists at the specified bus.</p><p>Parameters:</p><ul><li>result_jpc: Main JPC object containing all system data</li><li>jpc2: JPC object for DC system</li><li>dc<em>bus</em>id: ID of the DC bus to update</li><li>P_dc: DC power to add to the load</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runhpf.jl#LL435-L446">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.update_mode_1_converters!-NTuple{4, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.update_mode_1_converters!-NTuple{4, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.update_mode_1_converters!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_mode_1_converters!(result_jpc, jpc1, jpc2, current_power_values)</code></pre><p>Update converters with mode constant δs, Us (CONV_MODE==1). These converters have fixed AC voltage angle and magnitude, and the power is calculated from AC side.</p><p>Parameters:</p><ul><li>result_jpc: Main JPC object containing all system data</li><li>jpc1: JPC object for AC system</li><li>jpc2: JPC object for DC system</li><li>current<em>power</em>values: Dictionary to store current power values for convergence check</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runhpf.jl#LL158-L169">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.update_mode_3_converters!-NTuple{4, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.update_mode_3_converters!-NTuple{4, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.update_mode_3_converters!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_mode_3_converters!(result_jpc, jpc1, jpc2, current_power_values)</code></pre><p>Update converters with mode constant Ps, Us (CONV_MODE==3). These converters have fixed active power and AC voltage magnitude.</p><p>Parameters:</p><ul><li>result_jpc: Main JPC object containing all system data</li><li>jpc1: JPC object for AC system</li><li>jpc2: JPC object for DC system</li><li>current<em>power</em>values: Dictionary to store current power values for convergence check</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runhpf.jl#LL203-L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.update_mode_4_converters!-NTuple{4, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.update_mode_4_converters!-NTuple{4, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.update_mode_4_converters!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_mode_4_converters!(result_jpc, jpc1, jpc2, current_power_values)</code></pre><p>Update converters with mode constant Udc, Qs (CONV_MODE==4). These converters have fixed DC voltage and reactive power.</p><p>Parameters:</p><ul><li>result_jpc: Main JPC object containing all system data</li><li>jpc1: JPC object for AC system</li><li>jpc2: JPC object for DC system</li><li>current<em>power</em>values: Dictionary to store current power values for convergence check</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runhpf.jl#LL248-L259">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.update_mode_5_converters!-NTuple{4, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.update_mode_5_converters!-NTuple{4, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.update_mode_5_converters!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_mode_5_converters!(result_jpc, jpc1, jpc2, current_power_values)</code></pre><p>Update converters with mode constant Udc, Us (CONV_MODE==5). These converters have fixed DC voltage and AC voltage magnitude.</p><p>Parameters:</p><ul><li>result_jpc: Main JPC object containing all system data</li><li>jpc1: JPC object for AC system</li><li>jpc2: JPC object for DC system</li><li>current<em>power</em>values: Dictionary to store current power values for convergence check</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runhpf.jl#LL290-L301">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.update_mode_6_converters!-NTuple{4, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.update_mode_6_converters!-NTuple{4, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.update_mode_6_converters!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_mode_6_converters!(result_jpc, jpc1, jpc2, current_power_values)</code></pre><p>Update converters with mode Droop Udc, Constant Qs (CONV_MODE==6). These converters use DC voltage droop control and maintain constant reactive power.</p><p>Parameters:</p><ul><li>result_jpc: Main JPC object containing all system data</li><li>jpc1: JPC object for AC system</li><li>jpc2: JPC object for DC system</li><li>current<em>power</em>values: Dictionary to store current power values for convergence check</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runhpf.jl#LL337-L348">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.update_mode_7_converters!-NTuple{4, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.update_mode_7_converters!-NTuple{4, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.update_mode_7_converters!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_mode_7_converters!(result_jpc, jpc1, jpc2, current_power_values)</code></pre><p>Update converters with mode Droop Udc, Constant Us (CONV_MODE==7). These converters use DC voltage droop control and maintain constant AC voltage magnitude.</p><p>Parameters:</p><ul><li>result_jpc: Main JPC object containing all system data</li><li>jpc1: JPC object for AC system</li><li>jpc2: JPC object for DC system</li><li>current<em>power</em>values: Dictionary to store current power values for convergence check</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runhpf.jl#LL384-L395">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.I0_from_V012-Tuple{Any, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.I0_from_V012-Tuple{Any, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.I0_from_V012</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">I0_from_V012(V012, Y)</code></pre><p>Calculate zero sequence current from sequence voltages and admittance matrix.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runupf.jl#LL549-L553">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.I1_from_V012-Tuple{Any, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.I1_from_V012-Tuple{Any, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.I1_from_V012</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">I1_from_V012(V012, Y)</code></pre><p>Calculate positive sequence current from sequence voltages and admittance matrix.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runupf.jl#LL528-L532">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.I2_from_V012-Tuple{Any, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.I2_from_V012-Tuple{Any, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.I2_from_V012</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">I2_from_V012(V012, Y)</code></pre><p>Calculate negative sequence current from sequence voltages and admittance matrix.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runupf.jl#LL570-L574">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.I_from_SV_elementwise-Tuple{Any, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.I_from_SV_elementwise-Tuple{Any, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.I_from_SV_elementwise</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">I_from_SV_elementwise(S, V)</code></pre><p>Calculate current from complex power and voltage: I = conj(S/V).</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runupf.jl#LL965-L969">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.SVabc_from_SV012-Tuple{Any, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.SVabc_from_SV012-Tuple{Any, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.SVabc_from_SV012</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SVabc_from_SV012(S012, V012; n_res=nothing, idx=nothing)</code></pre><p>Convert sequence components of power and voltage to phase components.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runupf.jl#LL1145-L1149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.S_from_VI_elementwise-Tuple{Any, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.S_from_VI_elementwise-Tuple{Any, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.S_from_VI_elementwise</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">S_from_VI_elementwise(v, i)</code></pre><p>Calculate complex power from voltage and current: S = V * conj(I).</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runupf.jl#LL591-L595">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.V1_from_jpc-Tuple{Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.V1_from_jpc-Tuple{Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.V1_from_jpc</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">V1_from_jpc(jpc)</code></pre><p>Extract positive sequence voltage from JPC structure.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runupf.jl#LL600-L604">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.V_from_I-Tuple{Any, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.V_from_I-Tuple{Any, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.V_from_I</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">V_from_I(Y, I)</code></pre><p>Calculate voltage from current using V = Y\I.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runupf.jl#LL512-L516">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow._clean_up" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow._clean_up"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow._clean_up</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_clean_up(net, res=true)</code></pre><p>Clean up temporary data structures after power flow calculation.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runupf.jl#LL1197-L1201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow._get_p_q_gen_results_3ph-NTuple{5, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow._get_p_q_gen_results_3ph-NTuple{5, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow._get_p_q_gen_results_3ph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_get_p_q_gen_results_3ph(case, jpc_3ph, jpc0, jpc1, jpc2)</code></pre><p>Calculate active and reactive power for generators in three-phase system.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runupf.jl#LL1096-L1100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow._sum_by_group_nvals-Tuple{Any, Vararg{Any}}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow._sum_by_group_nvals-Tuple{Any, Vararg{Any}}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow._sum_by_group_nvals</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_sum_by_group_nvals(bus, vals...)</code></pre><p>Group values by bus and sum them within each group for multiple value arrays.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runupf.jl#LL867-L871">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.combine_X012-Tuple{Any, Any, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.combine_X012-Tuple{Any, Any, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.combine_X012</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">combine_X012(X0, X1, X2)</code></pre><p>Combine zero, positive, and negative sequence components into one matrix.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runupf.jl#LL611-L615">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.current_from_voltage_results-Tuple{Any, Any, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.current_from_voltage_results-Tuple{Any, Any, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.current_from_voltage_results</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">current_from_voltage_results(y_0_pu, y_1_pu, v_012_pu)</code></pre><p>Calculate sequence currents from sequence voltages and admittance matrices.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runupf.jl#LL620-L624">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.extratct_jpc_3ph-Tuple{HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_3ph}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.extratct_jpc_3ph-Tuple{HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_3ph}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.extratct_jpc_3ph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extratct_jpc_3ph(jpc_3ph::PowerFlow.JPC_3ph)</code></pre><p>Extract individual sequence components from a three-phase JPC object.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runupf.jl#LL371-L375">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_branch_flows_3ph-Tuple{Any, Any, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_branch_flows_3ph-Tuple{Any, Any, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_branch_flows_3ph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_branch_flows_3ph(jpc0, jpc1, jpc2)</code></pre><p>Calculate branch flows for three-phase system.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runupf.jl#LL930-L934">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_branch_results_3ph-NTuple{5, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_branch_results_3ph-NTuple{5, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_branch_results_3ph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_branch_results_3ph(jpc_3ph, jpc0, jpc1, jpc2, pq_buses)</code></pre><p>Extract branch results and write them to the appropriate dataframes.</p><p>Parameters:     results: result of runpf loadflow calculation     p: dict to store &quot;res<em>line&quot; and &quot;res</em>trafo&quot; Dataframes</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runupf.jl#LL911-L919">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_bus_results_3ph-Tuple{Any, Any, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_bus_results_3ph-Tuple{Any, Any, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_bus_results_3ph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_bus_results_3ph(case, jpc_3ph, bus_pq)</code></pre><p>Store three-phase bus results in the appropriate fields.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runupf.jl#LL1169-L1173">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_bus_v_results_3ph-NTuple{4, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_bus_v_results_3ph-NTuple{4, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_bus_v_results_3ph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_bus_v_results_3ph(jpc_3ph, jpc0, jpc1, jpc2)</code></pre><p>Calculate and store three-phase voltage results for all buses.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runupf.jl#LL632-L636">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_elements-Tuple{Any, JuliaPowerCase, Any, Any, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_elements-Tuple{Any, JuliaPowerCase, Any, Any, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_elements</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_elements(params, case::JuliaPowerCase, element, phase, typ)</code></pre><p>This function is used to get the elements of the load mapping. Automatically skips elements that don&#39;t exist in case.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runupf.jl#LL222-L227">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_ext_grid_results_3ph-NTuple{5, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_ext_grid_results_3ph-NTuple{5, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_ext_grid_results_3ph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_ext_grid_results_3ph(case, jpc_3ph, jpc0, jpc1, jpc2)</code></pre><p>Calculate and store three-phase external grid results.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runupf.jl#LL1020-L1024">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_full_branch_zero-Tuple{Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_full_branch_zero-Tuple{Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_full_branch_zero</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_full_branch_zero(jpc_3ph)</code></pre><p>Add non-service branches to zero sequence branch data.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runupf.jl#LL1320-L1324">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_gen_results_3ph-NTuple{6, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_gen_results_3ph-NTuple{6, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_gen_results_3ph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_gen_results_3ph(case, jpc_3ph, jpc0, jpc1, jpc2, pq_bus)</code></pre><p>Calculate and store three-phase generator results.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runupf.jl#LL984-L988">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_internal_variables-Tuple{JPC}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_internal_variables-Tuple{JPC}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_internal_variables</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_internal_variables(jpc::JPC)</code></pre><p>Retrieve stored internal variables for a JPC object.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runupf.jl#LL498-L502">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_p_q_b" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_p_q_b"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_p_q_b</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_p_q_b(case, jpc_3ph, element, suffix=nothing)</code></pre><p>Get active and reactive power values and bus indices for a specific element.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runupf.jl#LL757-L761">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_p_q_b_3ph-Tuple{Any, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_p_q_b_3ph-Tuple{Any, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_p_q_b_3ph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_p_q_b_3ph(net, element)</code></pre><p>Get three-phase active and reactive power values and bus indices for a specific element.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runupf.jl#LL844-L848">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_p_q_results_3ph-Tuple{Any, HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_3ph}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_p_q_results_3ph-Tuple{Any, HyDistFlow.TimeDomainPowerFlow.PowerFlow.Utils.JPC_3ph}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_p_q_results_3ph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_p_q_results_3ph(case, jpc_3ph::PowerFlow.JPC_3ph)</code></pre><p>Calculate and aggregate active and reactive power results for three-phase system.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runupf.jl#LL667-L671">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_pf_variables_from_JPC-Tuple{JPC}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_pf_variables_from_JPC-Tuple{JPC}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_pf_variables_from_JPC</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_pf_variables_from_JPC(jpc::JPC)</code></pre><p>Extract power flow variables from JPC structure.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runupf.jl#LL282-L286">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_pp_gen_results_3ph-NTuple{12, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_pp_gen_results_3ph-NTuple{12, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_pp_gen_results_3ph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_pp_gen_results_3ph(case, jpc_3ph, jpc0, jpc1, jpc2, b, pA, qA, pB, qB, pC, qC)</code></pre><p>Calculate and store three-phase generator results.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runupf.jl#LL1069-L1073">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_y_bus-Tuple{Any, Any, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_y_bus-Tuple{Any, Any, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.get_y_bus</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_y_bus(jpc0, jpc1, jpc2)</code></pre><p>Build admittance matrices for zero, positive, and negative sequence networks.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runupf.jl#LL404-L408">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.load_mapping-Tuple{JuliaPowerCase, JPC}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.load_mapping-Tuple{JuliaPowerCase, JPC}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.load_mapping</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">load_mapping(case::JuliaPowerCase, jpc1::JPC)</code></pre><p>Maps loads from the case to the power flow model, handling both wye and delta connections for all three phases.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runupf.jl#LL169-L174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.phase_shift_unit_operator-Tuple{Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.phase_shift_unit_operator-Tuple{Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.phase_shift_unit_operator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">phase_shift_unit_operator(angle_deg)</code></pre><p>Create a complex number representing a phase shift of the given angle in degrees.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runupf.jl#LL418-L422">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.phase_to_sequence-Tuple{Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.phase_to_sequence-Tuple{Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.phase_to_sequence</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">phase_to_sequence(Xabc)</code></pre><p>Transform phase components (a, b, c) to sequence components (zero, positive, negative).</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runupf.jl#LL442-L446">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.robust_process-Tuple{Any, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.robust_process-Tuple{Any, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.robust_process</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">robust_process(net, jpc)</code></pre><p>Process network and JPC data to ensure robust operation.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runupf.jl#LL1247-L1251">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.run_newton_raphson_pf-Tuple{JPC, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.run_newton_raphson_pf-Tuple{JPC, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.run_newton_raphson_pf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">run_newton_raphson_pf(jpc::JPC, opt)</code></pre><p>Run Newton-Raphson power flow calculation.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runupf.jl#LL456-L460">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.runupf-NTuple{5, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.runupf-NTuple{5, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.runupf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">runupf(case, jpc_3ph, gs_eg, bs_eg, opt)</code></pre><p>This function is used to run a local unbalanced power flow analysis on unsymmetrical load nodes</p><p>#Step1: find the unbalanced nodes in the system #Step2: find the interface branches of the unbalanced nodes and balanced nodes</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runupf.jl#LL1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.sequence_to_phase-Tuple{Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.sequence_to_phase-Tuple{Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.sequence_to_phase</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sequence_to_phase(X012)</code></pre><p>Transform sequence components (zero, positive, negative) to phase components (a, b, c).</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runupf.jl#LL427-L431">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.sum_by_group-Tuple{Any, Any, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.sum_by_group-Tuple{Any, Any, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.sum_by_group</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sum_by_group(bus, first_val, second_val)</code></pre><p>Group values by bus and sum them within each group.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runupf.jl#LL322-L326">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.write_pq_results_to_element" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.write_pq_results_to_element"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.write_pq_results_to_element</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">write_pq_results_to_element(case, jpc_3ph, element, suffix=nothing)</code></pre><p>Write power results to the specified element in jpc_3ph.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runupf.jl#LL733-L737">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.write_pq_results_to_element_3ph-Tuple{Any, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.write_pq_results_to_element_3ph-Tuple{Any, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.write_pq_results_to_element_3ph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">write_pq_results_to_element_3ph(net, element)</code></pre><p>Get p<em>mw and q</em>mvar for a specific pq element (&quot;load&quot;, &quot;sgen&quot;...). This function basically writes values from element table to res_element table.</p><p>Parameters:     net: pandapower network     element: element name (str) Returns:     net with updated results</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/runupf.jl#LL777-L788">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.total_load-Tuple{Any, Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.total_load-Tuple{Any, Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.total_load</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">total_load(bus, load)</code></pre><p>Calculate the total fixed and dispatchable load at each bus in the system, considering ZIP load model.</p><p><strong>Arguments</strong></p><ul><li><code>bus</code>: Bus data matrix containing bus information</li><li><code>load</code>: Load data matrix containing load model percentages</li></ul><p><strong>Returns</strong></p><ul><li><code>Pd</code>: Vector of real power demand at each bus</li><li><code>Qd</code>: Vector of reactive power demand at each bus (if want_Q=1)</li></ul><p>This function computes the total load at each bus using the ZIP load model, which represents loads as a combination of constant impedance (Z), constant current (I), and constant power (P) components. The percentages for each component are specified in the load matrix.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/total_load.jl#LL1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyDistFlow.TimeDomainPowerFlow.PowerFlow.total_load-Tuple{Any}" href="#HyDistFlow.TimeDomainPowerFlow.PowerFlow.total_load-Tuple{Any}"><code>HyDistFlow.TimeDomainPowerFlow.PowerFlow.total_load</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">total_load(bus)</code></pre><p>Calculate the total fixed and dispatchable load at each bus in the system using default ZIP parameters.</p><p><strong>Arguments</strong></p><ul><li><code>bus</code>: Bus data matrix containing bus information</li></ul><p><strong>Returns</strong></p><ul><li><code>Pd</code>: Vector of real power demand at each bus</li><li><code>Qd</code>: Vector of reactive power demand at each bus (if want_Q=1)</li></ul><p>This is an overloaded version of <code>total_load</code> that uses default ZIP model parameters. It computes the total load at each bus using the standard ZIP load model with default percentages for constant impedance (Z), constant current (I), and constant power (P) components.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/Luosipeng/HyDistFlow.jl/blob/0df98cb05f37fe5c74af37fe7e0c72778867f4fc/src/PowerFlow/src/total_load.jl#LL54-L69">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="utils.html">« Utils API</a><a class="docs-footer-nextpage" href="timedomainpowerflow.html">TimeDomainPowerFlow API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.13.0 on <span class="colophon-date" title="Thursday 2 October 2025 20:22">Thursday 2 October 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
